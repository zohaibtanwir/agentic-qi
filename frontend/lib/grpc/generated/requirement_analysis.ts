// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.10.0
//   protoc               v4.25.3
// source: requirement_analysis.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { CallContext, CallOptions } from "nice-grpc-common";

export const protobufPackage = "requirementanalysis.v1";

export interface AnalyzeRequest {
  requestId: string;
  jiraStory?: JiraStoryInput | undefined;
  freeForm?: FreeFormInput | undefined;
  transcript?: TranscriptInput | undefined;
  config: AnalysisConfig | undefined;
}

export interface JiraStoryInput {
  /** e.g., "ECOM-1234" */
  key: string;
  /** Story title */
  summary: string;
  /** Full description */
  description: string;
  /** Existing ACs */
  acceptanceCriteria: string[];
  /** Complexity estimate */
  storyPoints: number;
  /** Jira labels */
  labels: string[];
  /** Jira components */
  components: string[];
  /** High, Medium, Low */
  priority: string;
  /** Reporter email */
  reporter: string;
  /** Assignee email */
  assignee: string;
  /** Full Jira JSON if available */
  rawJson: string;
}

export interface FreeFormInput {
  /** Raw requirement text */
  text: string;
  /** Optional context */
  context: string;
  /** Optional title */
  title: string;
}

export interface TranscriptInput {
  /** Plain text with speaker labels */
  transcript: string;
  /** Meeting name */
  meetingTitle: string;
  /** Date of meeting */
  meetingDate: string;
  /** List of participants */
  participants: string[];
}

export interface AnalysisConfig {
  /** Validate against Domain Agent */
  includeDomainValidation: boolean;
  /** Auto-generate missing ACs */
  generateAcceptanceCriteria: boolean;
  /** Generate clarifying questions */
  generateQuestions: boolean;
  /** anthropic, openai, gemini */
  llmProvider: string;
  /** Domain context (e.g., "ecommerce") */
  domain: string;
}

export interface AnalyzeResponse {
  requestId: string;
  success: boolean;
  qualityScore: QualityScore | undefined;
  extractedRequirement: ExtractedRequirement | undefined;
  gaps: Gap[];
  questions: ClarifyingQuestion[];
  generatedAcs: GeneratedAC[];
  domainValidation: DomainValidation | undefined;
  readyForTestGeneration: boolean;
  blockers: string[];
  metadata: AnalysisMetadata | undefined;
  error: string;
}

export interface QualityScore {
  /** 0-100 */
  overallScore: number;
  /** A, B, C, D, F */
  overallGrade: string;
  clarity: DimensionScore | undefined;
  completeness: DimensionScore | undefined;
  testability: DimensionScore | undefined;
  consistency:
    | DimensionScore
    | undefined;
  /** Action recommendation */
  recommendation: string;
}

export interface DimensionScore {
  /** 0-100 */
  score: number;
  /** A, B, C, D, F */
  grade: string;
  /** Specific issues found */
  issues: string[];
}

export interface ExtractedRequirement {
  title: string;
  description: string;
  structure:
    | RequirementStructure
    | undefined;
  /** Original acceptance criteria */
  originalAcs: string[];
  /** jira, free_form, transcript */
  inputType: string;
}

export interface RequirementStructure {
  /** Who performs the action */
  actor: string;
  /** Other actors involved */
  secondaryActors: string[];
  /** What is being done */
  action: string;
  /** What is acted upon */
  object: string;
  /** Why / expected result */
  outcome: string;
  /** Required starting state */
  preconditions: string[];
  /** Expected end state */
  postconditions: string[];
  /** What initiates the action */
  triggers: string[];
  /** Limitations or rules */
  constraints: string[];
  /** Domain entities mentioned */
  entities: string[];
}

export interface Gap {
  /** e.g., "GAP-001" */
  id: string;
  /** missing_ac, ambiguous_term, etc. */
  category: string;
  /** high, medium, low */
  severity: string;
  /** What's missing or unclear */
  description: string;
  /** Where in the requirement */
  location: string;
  /** How to fix it */
  suggestion: string;
}

export interface ClarifyingQuestion {
  /** e.g., "Q-001" */
  id: string;
  /** high, medium, low */
  priority: string;
  /** error_handling, scope, ux, etc. */
  category: string;
  /** The question to ask */
  question: string;
  /** Why this question matters */
  context: string;
  /** Possible answers */
  suggestedAnswers: string[];
  /** Filled in during reanalysis */
  answer: string;
}

export interface GeneratedAC {
  /** e.g., "AC-GEN-001" */
  id: string;
  /** gap_detection, domain_knowledge, structure_extraction */
  source: string;
  /** 0.0 - 1.0 */
  confidence: number;
  /** Plain text AC */
  text: string;
  /** Gherkin format */
  gherkin: string;
  /** User decision */
  accepted: boolean;
}

export interface DomainValidation {
  valid: boolean;
  entitiesFound: EntityMapping[];
  rulesApplicable: ApplicableRule[];
  warnings: DomainWarning[];
}

export interface EntityMapping {
  /** Term from requirement */
  term: string;
  /** Domain entity name */
  mappedEntity: string;
  /** Confidence score */
  confidence: number;
  /** Entity description */
  domainDescription: string;
}

export interface ApplicableRule {
  ruleId: string;
  rule: string;
  /** high, medium, low */
  relevance: string;
}

export interface DomainWarning {
  /** missing_entity, rule_violation, etc. */
  type: string;
  message: string;
  suggestion: string;
}

export interface AnalysisMetadata {
  llmProvider: string;
  llmModel: string;
  tokensUsed: number;
  analysisTimeMs: number;
  /** jira, free_form, transcript */
  inputType: string;
  agentVersion: string;
}

export interface ReanalyzeRequest {
  requestId: string;
  /** Link to original analysis */
  originalRequestId: string;
  /** Updated content */
  updatedTitle: string;
  updatedDescription: string;
  updatedAcs: string[];
  /** Answered questions */
  answeredQuestions: AnsweredQuestion[];
  /** Accepted/rejected generated ACs */
  acDecisions: ACDecision[];
  /** Additional context provided */
  additionalContext: string;
  config: AnalysisConfig | undefined;
}

export interface AnsweredQuestion {
  questionId: string;
  answer: string;
}

export interface ACDecision {
  acId: string;
  accepted: boolean;
  /** If user edited the generated AC */
  modifiedText: string;
}

export interface ExportRequest {
  requestId: string;
  /** ID of the analysis to export */
  analysisRequestId: string;
  /** text, json */
  format: string;
  includeRecommendations: boolean;
  includeGeneratedAcs: boolean;
}

export interface ExportResponse {
  requestId: string;
  success: boolean;
  format: string;
  /** The exported report content */
  content: string;
  /** Suggested filename */
  filename: string;
  error: string;
}

export interface ForwardRequest {
  requestId: string;
  /** ID of the analysis to forward */
  analysisRequestId: string;
  /** Include agent-generated ACs */
  includeGeneratedAcs: boolean;
  /** Include domain validation results */
  includeDomainContext: boolean;
  /** Config for Test Cases Agent */
  testCasesConfig: TestCasesConfig | undefined;
}

export interface TestCasesConfig {
  /** gherkin, traditional, json */
  outputFormat: string;
  /** quick, standard, exhaustive */
  coverageLevel: string;
  /** functional, negative, boundary, edge_case */
  testTypes: string[];
  /** anthropic, openai, gemini */
  llmProvider: string;
  checkDuplicates: boolean;
  maxTestCases: number;
}

export interface ForwardResponse {
  requestId: string;
  success: boolean;
  /** Request ID from Test Cases Agent */
  testCasesRequestId: string;
  testCasesGenerated: number;
  /** The requirement sent to TCA */
  structuredRequirementJson: string;
  error: string;
}

export interface HealthCheckRequest {
}

export interface HealthCheckResponse {
  /** healthy, degraded, unhealthy */
  status: string;
  /** Component health status */
  components: { [key: string]: string };
}

export interface HealthCheckResponse_ComponentsEntry {
  key: string;
  value: string;
}

export interface StructuredRequirement {
  id: string;
  title: string;
  description: string;
  acceptanceCriteria: string[];
  domain: string;
  entities: string[];
  preconditions: string[];
  additionalContext: string;
  /** Analysis metadata */
  qualityScore: number;
  gapsAddressed: boolean;
  questionsAnswered: boolean;
}

function createBaseAnalyzeRequest(): AnalyzeRequest {
  return { requestId: "", jiraStory: undefined, freeForm: undefined, transcript: undefined, config: undefined };
}

export const AnalyzeRequest: MessageFns<AnalyzeRequest> = {
  encode(message: AnalyzeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.jiraStory !== undefined) {
      JiraStoryInput.encode(message.jiraStory, writer.uint32(18).fork()).join();
    }
    if (message.freeForm !== undefined) {
      FreeFormInput.encode(message.freeForm, writer.uint32(26).fork()).join();
    }
    if (message.transcript !== undefined) {
      TranscriptInput.encode(message.transcript, writer.uint32(34).fork()).join();
    }
    if (message.config !== undefined) {
      AnalysisConfig.encode(message.config, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalyzeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalyzeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.jiraStory = JiraStoryInput.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.freeForm = FreeFormInput.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.transcript = TranscriptInput.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.config = AnalysisConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalyzeRequest {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      jiraStory: isSet(object.jiraStory) ? JiraStoryInput.fromJSON(object.jiraStory) : undefined,
      freeForm: isSet(object.freeForm) ? FreeFormInput.fromJSON(object.freeForm) : undefined,
      transcript: isSet(object.transcript) ? TranscriptInput.fromJSON(object.transcript) : undefined,
      config: isSet(object.config) ? AnalysisConfig.fromJSON(object.config) : undefined,
    };
  },

  toJSON(message: AnalyzeRequest): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.jiraStory !== undefined) {
      obj.jiraStory = JiraStoryInput.toJSON(message.jiraStory);
    }
    if (message.freeForm !== undefined) {
      obj.freeForm = FreeFormInput.toJSON(message.freeForm);
    }
    if (message.transcript !== undefined) {
      obj.transcript = TranscriptInput.toJSON(message.transcript);
    }
    if (message.config !== undefined) {
      obj.config = AnalysisConfig.toJSON(message.config);
    }
    return obj;
  },

  create(base?: DeepPartial<AnalyzeRequest>): AnalyzeRequest {
    return AnalyzeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnalyzeRequest>): AnalyzeRequest {
    const message = createBaseAnalyzeRequest();
    message.requestId = object.requestId ?? "";
    message.jiraStory = (object.jiraStory !== undefined && object.jiraStory !== null)
      ? JiraStoryInput.fromPartial(object.jiraStory)
      : undefined;
    message.freeForm = (object.freeForm !== undefined && object.freeForm !== null)
      ? FreeFormInput.fromPartial(object.freeForm)
      : undefined;
    message.transcript = (object.transcript !== undefined && object.transcript !== null)
      ? TranscriptInput.fromPartial(object.transcript)
      : undefined;
    message.config = (object.config !== undefined && object.config !== null)
      ? AnalysisConfig.fromPartial(object.config)
      : undefined;
    return message;
  },
};

function createBaseJiraStoryInput(): JiraStoryInput {
  return {
    key: "",
    summary: "",
    description: "",
    acceptanceCriteria: [],
    storyPoints: 0,
    labels: [],
    components: [],
    priority: "",
    reporter: "",
    assignee: "",
    rawJson: "",
  };
}

export const JiraStoryInput: MessageFns<JiraStoryInput> = {
  encode(message: JiraStoryInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.summary !== "") {
      writer.uint32(18).string(message.summary);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    for (const v of message.acceptanceCriteria) {
      writer.uint32(34).string(v!);
    }
    if (message.storyPoints !== 0) {
      writer.uint32(40).int32(message.storyPoints);
    }
    for (const v of message.labels) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.components) {
      writer.uint32(58).string(v!);
    }
    if (message.priority !== "") {
      writer.uint32(66).string(message.priority);
    }
    if (message.reporter !== "") {
      writer.uint32(74).string(message.reporter);
    }
    if (message.assignee !== "") {
      writer.uint32(82).string(message.assignee);
    }
    if (message.rawJson !== "") {
      writer.uint32(90).string(message.rawJson);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JiraStoryInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJiraStoryInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.summary = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.acceptanceCriteria.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.storyPoints = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.labels.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.components.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.priority = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.reporter = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.assignee = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.rawJson = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JiraStoryInput {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      summary: isSet(object.summary) ? globalThis.String(object.summary) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      acceptanceCriteria: globalThis.Array.isArray(object?.acceptanceCriteria)
        ? object.acceptanceCriteria.map((e: any) => globalThis.String(e))
        : [],
      storyPoints: isSet(object.storyPoints) ? globalThis.Number(object.storyPoints) : 0,
      labels: globalThis.Array.isArray(object?.labels) ? object.labels.map((e: any) => globalThis.String(e)) : [],
      components: globalThis.Array.isArray(object?.components)
        ? object.components.map((e: any) => globalThis.String(e))
        : [],
      priority: isSet(object.priority) ? globalThis.String(object.priority) : "",
      reporter: isSet(object.reporter) ? globalThis.String(object.reporter) : "",
      assignee: isSet(object.assignee) ? globalThis.String(object.assignee) : "",
      rawJson: isSet(object.rawJson) ? globalThis.String(object.rawJson) : "",
    };
  },

  toJSON(message: JiraStoryInput): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.summary !== "") {
      obj.summary = message.summary;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.acceptanceCriteria?.length) {
      obj.acceptanceCriteria = message.acceptanceCriteria;
    }
    if (message.storyPoints !== 0) {
      obj.storyPoints = Math.round(message.storyPoints);
    }
    if (message.labels?.length) {
      obj.labels = message.labels;
    }
    if (message.components?.length) {
      obj.components = message.components;
    }
    if (message.priority !== "") {
      obj.priority = message.priority;
    }
    if (message.reporter !== "") {
      obj.reporter = message.reporter;
    }
    if (message.assignee !== "") {
      obj.assignee = message.assignee;
    }
    if (message.rawJson !== "") {
      obj.rawJson = message.rawJson;
    }
    return obj;
  },

  create(base?: DeepPartial<JiraStoryInput>): JiraStoryInput {
    return JiraStoryInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<JiraStoryInput>): JiraStoryInput {
    const message = createBaseJiraStoryInput();
    message.key = object.key ?? "";
    message.summary = object.summary ?? "";
    message.description = object.description ?? "";
    message.acceptanceCriteria = object.acceptanceCriteria?.map((e) => e) || [];
    message.storyPoints = object.storyPoints ?? 0;
    message.labels = object.labels?.map((e) => e) || [];
    message.components = object.components?.map((e) => e) || [];
    message.priority = object.priority ?? "";
    message.reporter = object.reporter ?? "";
    message.assignee = object.assignee ?? "";
    message.rawJson = object.rawJson ?? "";
    return message;
  },
};

function createBaseFreeFormInput(): FreeFormInput {
  return { text: "", context: "", title: "" };
}

export const FreeFormInput: MessageFns<FreeFormInput> = {
  encode(message: FreeFormInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.context !== "") {
      writer.uint32(18).string(message.context);
    }
    if (message.title !== "") {
      writer.uint32(26).string(message.title);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FreeFormInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFreeFormInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.context = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.title = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FreeFormInput {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      context: isSet(object.context) ? globalThis.String(object.context) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
    };
  },

  toJSON(message: FreeFormInput): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.context !== "") {
      obj.context = message.context;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    return obj;
  },

  create(base?: DeepPartial<FreeFormInput>): FreeFormInput {
    return FreeFormInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FreeFormInput>): FreeFormInput {
    const message = createBaseFreeFormInput();
    message.text = object.text ?? "";
    message.context = object.context ?? "";
    message.title = object.title ?? "";
    return message;
  },
};

function createBaseTranscriptInput(): TranscriptInput {
  return { transcript: "", meetingTitle: "", meetingDate: "", participants: [] };
}

export const TranscriptInput: MessageFns<TranscriptInput> = {
  encode(message: TranscriptInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transcript !== "") {
      writer.uint32(10).string(message.transcript);
    }
    if (message.meetingTitle !== "") {
      writer.uint32(18).string(message.meetingTitle);
    }
    if (message.meetingDate !== "") {
      writer.uint32(26).string(message.meetingDate);
    }
    for (const v of message.participants) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TranscriptInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTranscriptInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transcript = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.meetingTitle = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.meetingDate = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.participants.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TranscriptInput {
    return {
      transcript: isSet(object.transcript) ? globalThis.String(object.transcript) : "",
      meetingTitle: isSet(object.meetingTitle) ? globalThis.String(object.meetingTitle) : "",
      meetingDate: isSet(object.meetingDate) ? globalThis.String(object.meetingDate) : "",
      participants: globalThis.Array.isArray(object?.participants)
        ? object.participants.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: TranscriptInput): unknown {
    const obj: any = {};
    if (message.transcript !== "") {
      obj.transcript = message.transcript;
    }
    if (message.meetingTitle !== "") {
      obj.meetingTitle = message.meetingTitle;
    }
    if (message.meetingDate !== "") {
      obj.meetingDate = message.meetingDate;
    }
    if (message.participants?.length) {
      obj.participants = message.participants;
    }
    return obj;
  },

  create(base?: DeepPartial<TranscriptInput>): TranscriptInput {
    return TranscriptInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TranscriptInput>): TranscriptInput {
    const message = createBaseTranscriptInput();
    message.transcript = object.transcript ?? "";
    message.meetingTitle = object.meetingTitle ?? "";
    message.meetingDate = object.meetingDate ?? "";
    message.participants = object.participants?.map((e) => e) || [];
    return message;
  },
};

function createBaseAnalysisConfig(): AnalysisConfig {
  return {
    includeDomainValidation: false,
    generateAcceptanceCriteria: false,
    generateQuestions: false,
    llmProvider: "",
    domain: "",
  };
}

export const AnalysisConfig: MessageFns<AnalysisConfig> = {
  encode(message: AnalysisConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.includeDomainValidation !== false) {
      writer.uint32(8).bool(message.includeDomainValidation);
    }
    if (message.generateAcceptanceCriteria !== false) {
      writer.uint32(16).bool(message.generateAcceptanceCriteria);
    }
    if (message.generateQuestions !== false) {
      writer.uint32(24).bool(message.generateQuestions);
    }
    if (message.llmProvider !== "") {
      writer.uint32(34).string(message.llmProvider);
    }
    if (message.domain !== "") {
      writer.uint32(42).string(message.domain);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalysisConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalysisConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.includeDomainValidation = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.generateAcceptanceCriteria = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.generateQuestions = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.llmProvider = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.domain = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalysisConfig {
    return {
      includeDomainValidation: isSet(object.includeDomainValidation)
        ? globalThis.Boolean(object.includeDomainValidation)
        : false,
      generateAcceptanceCriteria: isSet(object.generateAcceptanceCriteria)
        ? globalThis.Boolean(object.generateAcceptanceCriteria)
        : false,
      generateQuestions: isSet(object.generateQuestions) ? globalThis.Boolean(object.generateQuestions) : false,
      llmProvider: isSet(object.llmProvider) ? globalThis.String(object.llmProvider) : "",
      domain: isSet(object.domain) ? globalThis.String(object.domain) : "",
    };
  },

  toJSON(message: AnalysisConfig): unknown {
    const obj: any = {};
    if (message.includeDomainValidation !== false) {
      obj.includeDomainValidation = message.includeDomainValidation;
    }
    if (message.generateAcceptanceCriteria !== false) {
      obj.generateAcceptanceCriteria = message.generateAcceptanceCriteria;
    }
    if (message.generateQuestions !== false) {
      obj.generateQuestions = message.generateQuestions;
    }
    if (message.llmProvider !== "") {
      obj.llmProvider = message.llmProvider;
    }
    if (message.domain !== "") {
      obj.domain = message.domain;
    }
    return obj;
  },

  create(base?: DeepPartial<AnalysisConfig>): AnalysisConfig {
    return AnalysisConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnalysisConfig>): AnalysisConfig {
    const message = createBaseAnalysisConfig();
    message.includeDomainValidation = object.includeDomainValidation ?? false;
    message.generateAcceptanceCriteria = object.generateAcceptanceCriteria ?? false;
    message.generateQuestions = object.generateQuestions ?? false;
    message.llmProvider = object.llmProvider ?? "";
    message.domain = object.domain ?? "";
    return message;
  },
};

function createBaseAnalyzeResponse(): AnalyzeResponse {
  return {
    requestId: "",
    success: false,
    qualityScore: undefined,
    extractedRequirement: undefined,
    gaps: [],
    questions: [],
    generatedAcs: [],
    domainValidation: undefined,
    readyForTestGeneration: false,
    blockers: [],
    metadata: undefined,
    error: "",
  };
}

export const AnalyzeResponse: MessageFns<AnalyzeResponse> = {
  encode(message: AnalyzeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.qualityScore !== undefined) {
      QualityScore.encode(message.qualityScore, writer.uint32(26).fork()).join();
    }
    if (message.extractedRequirement !== undefined) {
      ExtractedRequirement.encode(message.extractedRequirement, writer.uint32(34).fork()).join();
    }
    for (const v of message.gaps) {
      Gap.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.questions) {
      ClarifyingQuestion.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.generatedAcs) {
      GeneratedAC.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.domainValidation !== undefined) {
      DomainValidation.encode(message.domainValidation, writer.uint32(66).fork()).join();
    }
    if (message.readyForTestGeneration !== false) {
      writer.uint32(72).bool(message.readyForTestGeneration);
    }
    for (const v of message.blockers) {
      writer.uint32(82).string(v!);
    }
    if (message.metadata !== undefined) {
      AnalysisMetadata.encode(message.metadata, writer.uint32(90).fork()).join();
    }
    if (message.error !== "") {
      writer.uint32(98).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalyzeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalyzeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.qualityScore = QualityScore.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.extractedRequirement = ExtractedRequirement.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.gaps.push(Gap.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.questions.push(ClarifyingQuestion.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.generatedAcs.push(GeneratedAC.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.domainValidation = DomainValidation.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.readyForTestGeneration = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.blockers.push(reader.string());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.metadata = AnalysisMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalyzeResponse {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      qualityScore: isSet(object.qualityScore) ? QualityScore.fromJSON(object.qualityScore) : undefined,
      extractedRequirement: isSet(object.extractedRequirement)
        ? ExtractedRequirement.fromJSON(object.extractedRequirement)
        : undefined,
      gaps: globalThis.Array.isArray(object?.gaps) ? object.gaps.map((e: any) => Gap.fromJSON(e)) : [],
      questions: globalThis.Array.isArray(object?.questions)
        ? object.questions.map((e: any) => ClarifyingQuestion.fromJSON(e))
        : [],
      generatedAcs: globalThis.Array.isArray(object?.generatedAcs)
        ? object.generatedAcs.map((e: any) => GeneratedAC.fromJSON(e))
        : [],
      domainValidation: isSet(object.domainValidation) ? DomainValidation.fromJSON(object.domainValidation) : undefined,
      readyForTestGeneration: isSet(object.readyForTestGeneration)
        ? globalThis.Boolean(object.readyForTestGeneration)
        : false,
      blockers: globalThis.Array.isArray(object?.blockers) ? object.blockers.map((e: any) => globalThis.String(e)) : [],
      metadata: isSet(object.metadata) ? AnalysisMetadata.fromJSON(object.metadata) : undefined,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: AnalyzeResponse): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.qualityScore !== undefined) {
      obj.qualityScore = QualityScore.toJSON(message.qualityScore);
    }
    if (message.extractedRequirement !== undefined) {
      obj.extractedRequirement = ExtractedRequirement.toJSON(message.extractedRequirement);
    }
    if (message.gaps?.length) {
      obj.gaps = message.gaps.map((e) => Gap.toJSON(e));
    }
    if (message.questions?.length) {
      obj.questions = message.questions.map((e) => ClarifyingQuestion.toJSON(e));
    }
    if (message.generatedAcs?.length) {
      obj.generatedAcs = message.generatedAcs.map((e) => GeneratedAC.toJSON(e));
    }
    if (message.domainValidation !== undefined) {
      obj.domainValidation = DomainValidation.toJSON(message.domainValidation);
    }
    if (message.readyForTestGeneration !== false) {
      obj.readyForTestGeneration = message.readyForTestGeneration;
    }
    if (message.blockers?.length) {
      obj.blockers = message.blockers;
    }
    if (message.metadata !== undefined) {
      obj.metadata = AnalysisMetadata.toJSON(message.metadata);
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create(base?: DeepPartial<AnalyzeResponse>): AnalyzeResponse {
    return AnalyzeResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnalyzeResponse>): AnalyzeResponse {
    const message = createBaseAnalyzeResponse();
    message.requestId = object.requestId ?? "";
    message.success = object.success ?? false;
    message.qualityScore = (object.qualityScore !== undefined && object.qualityScore !== null)
      ? QualityScore.fromPartial(object.qualityScore)
      : undefined;
    message.extractedRequirement = (object.extractedRequirement !== undefined && object.extractedRequirement !== null)
      ? ExtractedRequirement.fromPartial(object.extractedRequirement)
      : undefined;
    message.gaps = object.gaps?.map((e) => Gap.fromPartial(e)) || [];
    message.questions = object.questions?.map((e) => ClarifyingQuestion.fromPartial(e)) || [];
    message.generatedAcs = object.generatedAcs?.map((e) => GeneratedAC.fromPartial(e)) || [];
    message.domainValidation = (object.domainValidation !== undefined && object.domainValidation !== null)
      ? DomainValidation.fromPartial(object.domainValidation)
      : undefined;
    message.readyForTestGeneration = object.readyForTestGeneration ?? false;
    message.blockers = object.blockers?.map((e) => e) || [];
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? AnalysisMetadata.fromPartial(object.metadata)
      : undefined;
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseQualityScore(): QualityScore {
  return {
    overallScore: 0,
    overallGrade: "",
    clarity: undefined,
    completeness: undefined,
    testability: undefined,
    consistency: undefined,
    recommendation: "",
  };
}

export const QualityScore: MessageFns<QualityScore> = {
  encode(message: QualityScore, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.overallScore !== 0) {
      writer.uint32(8).int32(message.overallScore);
    }
    if (message.overallGrade !== "") {
      writer.uint32(18).string(message.overallGrade);
    }
    if (message.clarity !== undefined) {
      DimensionScore.encode(message.clarity, writer.uint32(26).fork()).join();
    }
    if (message.completeness !== undefined) {
      DimensionScore.encode(message.completeness, writer.uint32(34).fork()).join();
    }
    if (message.testability !== undefined) {
      DimensionScore.encode(message.testability, writer.uint32(42).fork()).join();
    }
    if (message.consistency !== undefined) {
      DimensionScore.encode(message.consistency, writer.uint32(50).fork()).join();
    }
    if (message.recommendation !== "") {
      writer.uint32(58).string(message.recommendation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QualityScore {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQualityScore();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.overallScore = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.overallGrade = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clarity = DimensionScore.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.completeness = DimensionScore.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.testability = DimensionScore.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.consistency = DimensionScore.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.recommendation = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QualityScore {
    return {
      overallScore: isSet(object.overallScore) ? globalThis.Number(object.overallScore) : 0,
      overallGrade: isSet(object.overallGrade) ? globalThis.String(object.overallGrade) : "",
      clarity: isSet(object.clarity) ? DimensionScore.fromJSON(object.clarity) : undefined,
      completeness: isSet(object.completeness) ? DimensionScore.fromJSON(object.completeness) : undefined,
      testability: isSet(object.testability) ? DimensionScore.fromJSON(object.testability) : undefined,
      consistency: isSet(object.consistency) ? DimensionScore.fromJSON(object.consistency) : undefined,
      recommendation: isSet(object.recommendation) ? globalThis.String(object.recommendation) : "",
    };
  },

  toJSON(message: QualityScore): unknown {
    const obj: any = {};
    if (message.overallScore !== 0) {
      obj.overallScore = Math.round(message.overallScore);
    }
    if (message.overallGrade !== "") {
      obj.overallGrade = message.overallGrade;
    }
    if (message.clarity !== undefined) {
      obj.clarity = DimensionScore.toJSON(message.clarity);
    }
    if (message.completeness !== undefined) {
      obj.completeness = DimensionScore.toJSON(message.completeness);
    }
    if (message.testability !== undefined) {
      obj.testability = DimensionScore.toJSON(message.testability);
    }
    if (message.consistency !== undefined) {
      obj.consistency = DimensionScore.toJSON(message.consistency);
    }
    if (message.recommendation !== "") {
      obj.recommendation = message.recommendation;
    }
    return obj;
  },

  create(base?: DeepPartial<QualityScore>): QualityScore {
    return QualityScore.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QualityScore>): QualityScore {
    const message = createBaseQualityScore();
    message.overallScore = object.overallScore ?? 0;
    message.overallGrade = object.overallGrade ?? "";
    message.clarity = (object.clarity !== undefined && object.clarity !== null)
      ? DimensionScore.fromPartial(object.clarity)
      : undefined;
    message.completeness = (object.completeness !== undefined && object.completeness !== null)
      ? DimensionScore.fromPartial(object.completeness)
      : undefined;
    message.testability = (object.testability !== undefined && object.testability !== null)
      ? DimensionScore.fromPartial(object.testability)
      : undefined;
    message.consistency = (object.consistency !== undefined && object.consistency !== null)
      ? DimensionScore.fromPartial(object.consistency)
      : undefined;
    message.recommendation = object.recommendation ?? "";
    return message;
  },
};

function createBaseDimensionScore(): DimensionScore {
  return { score: 0, grade: "", issues: [] };
}

export const DimensionScore: MessageFns<DimensionScore> = {
  encode(message: DimensionScore, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.score !== 0) {
      writer.uint32(8).int32(message.score);
    }
    if (message.grade !== "") {
      writer.uint32(18).string(message.grade);
    }
    for (const v of message.issues) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DimensionScore {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDimensionScore();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.score = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.grade = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.issues.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DimensionScore {
    return {
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      grade: isSet(object.grade) ? globalThis.String(object.grade) : "",
      issues: globalThis.Array.isArray(object?.issues) ? object.issues.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: DimensionScore): unknown {
    const obj: any = {};
    if (message.score !== 0) {
      obj.score = Math.round(message.score);
    }
    if (message.grade !== "") {
      obj.grade = message.grade;
    }
    if (message.issues?.length) {
      obj.issues = message.issues;
    }
    return obj;
  },

  create(base?: DeepPartial<DimensionScore>): DimensionScore {
    return DimensionScore.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DimensionScore>): DimensionScore {
    const message = createBaseDimensionScore();
    message.score = object.score ?? 0;
    message.grade = object.grade ?? "";
    message.issues = object.issues?.map((e) => e) || [];
    return message;
  },
};

function createBaseExtractedRequirement(): ExtractedRequirement {
  return { title: "", description: "", structure: undefined, originalAcs: [], inputType: "" };
}

export const ExtractedRequirement: MessageFns<ExtractedRequirement> = {
  encode(message: ExtractedRequirement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.structure !== undefined) {
      RequirementStructure.encode(message.structure, writer.uint32(26).fork()).join();
    }
    for (const v of message.originalAcs) {
      writer.uint32(34).string(v!);
    }
    if (message.inputType !== "") {
      writer.uint32(42).string(message.inputType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExtractedRequirement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExtractedRequirement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.structure = RequirementStructure.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.originalAcs.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.inputType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExtractedRequirement {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      structure: isSet(object.structure) ? RequirementStructure.fromJSON(object.structure) : undefined,
      originalAcs: globalThis.Array.isArray(object?.originalAcs)
        ? object.originalAcs.map((e: any) => globalThis.String(e))
        : [],
      inputType: isSet(object.inputType) ? globalThis.String(object.inputType) : "",
    };
  },

  toJSON(message: ExtractedRequirement): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.structure !== undefined) {
      obj.structure = RequirementStructure.toJSON(message.structure);
    }
    if (message.originalAcs?.length) {
      obj.originalAcs = message.originalAcs;
    }
    if (message.inputType !== "") {
      obj.inputType = message.inputType;
    }
    return obj;
  },

  create(base?: DeepPartial<ExtractedRequirement>): ExtractedRequirement {
    return ExtractedRequirement.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExtractedRequirement>): ExtractedRequirement {
    const message = createBaseExtractedRequirement();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.structure = (object.structure !== undefined && object.structure !== null)
      ? RequirementStructure.fromPartial(object.structure)
      : undefined;
    message.originalAcs = object.originalAcs?.map((e) => e) || [];
    message.inputType = object.inputType ?? "";
    return message;
  },
};

function createBaseRequirementStructure(): RequirementStructure {
  return {
    actor: "",
    secondaryActors: [],
    action: "",
    object: "",
    outcome: "",
    preconditions: [],
    postconditions: [],
    triggers: [],
    constraints: [],
    entities: [],
  };
}

export const RequirementStructure: MessageFns<RequirementStructure> = {
  encode(message: RequirementStructure, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.actor !== "") {
      writer.uint32(10).string(message.actor);
    }
    for (const v of message.secondaryActors) {
      writer.uint32(18).string(v!);
    }
    if (message.action !== "") {
      writer.uint32(26).string(message.action);
    }
    if (message.object !== "") {
      writer.uint32(34).string(message.object);
    }
    if (message.outcome !== "") {
      writer.uint32(42).string(message.outcome);
    }
    for (const v of message.preconditions) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.postconditions) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.triggers) {
      writer.uint32(66).string(v!);
    }
    for (const v of message.constraints) {
      writer.uint32(74).string(v!);
    }
    for (const v of message.entities) {
      writer.uint32(82).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequirementStructure {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequirementStructure();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.actor = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.secondaryActors.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.action = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.object = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.outcome = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.preconditions.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.postconditions.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.triggers.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.constraints.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.entities.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequirementStructure {
    return {
      actor: isSet(object.actor) ? globalThis.String(object.actor) : "",
      secondaryActors: globalThis.Array.isArray(object?.secondaryActors)
        ? object.secondaryActors.map((e: any) => globalThis.String(e))
        : [],
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      object: isSet(object.object) ? globalThis.String(object.object) : "",
      outcome: isSet(object.outcome) ? globalThis.String(object.outcome) : "",
      preconditions: globalThis.Array.isArray(object?.preconditions)
        ? object.preconditions.map((e: any) => globalThis.String(e))
        : [],
      postconditions: globalThis.Array.isArray(object?.postconditions)
        ? object.postconditions.map((e: any) => globalThis.String(e))
        : [],
      triggers: globalThis.Array.isArray(object?.triggers) ? object.triggers.map((e: any) => globalThis.String(e)) : [],
      constraints: globalThis.Array.isArray(object?.constraints)
        ? object.constraints.map((e: any) => globalThis.String(e))
        : [],
      entities: globalThis.Array.isArray(object?.entities) ? object.entities.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: RequirementStructure): unknown {
    const obj: any = {};
    if (message.actor !== "") {
      obj.actor = message.actor;
    }
    if (message.secondaryActors?.length) {
      obj.secondaryActors = message.secondaryActors;
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.object !== "") {
      obj.object = message.object;
    }
    if (message.outcome !== "") {
      obj.outcome = message.outcome;
    }
    if (message.preconditions?.length) {
      obj.preconditions = message.preconditions;
    }
    if (message.postconditions?.length) {
      obj.postconditions = message.postconditions;
    }
    if (message.triggers?.length) {
      obj.triggers = message.triggers;
    }
    if (message.constraints?.length) {
      obj.constraints = message.constraints;
    }
    if (message.entities?.length) {
      obj.entities = message.entities;
    }
    return obj;
  },

  create(base?: DeepPartial<RequirementStructure>): RequirementStructure {
    return RequirementStructure.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RequirementStructure>): RequirementStructure {
    const message = createBaseRequirementStructure();
    message.actor = object.actor ?? "";
    message.secondaryActors = object.secondaryActors?.map((e) => e) || [];
    message.action = object.action ?? "";
    message.object = object.object ?? "";
    message.outcome = object.outcome ?? "";
    message.preconditions = object.preconditions?.map((e) => e) || [];
    message.postconditions = object.postconditions?.map((e) => e) || [];
    message.triggers = object.triggers?.map((e) => e) || [];
    message.constraints = object.constraints?.map((e) => e) || [];
    message.entities = object.entities?.map((e) => e) || [];
    return message;
  },
};

function createBaseGap(): Gap {
  return { id: "", category: "", severity: "", description: "", location: "", suggestion: "" };
}

export const Gap: MessageFns<Gap> = {
  encode(message: Gap, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.category !== "") {
      writer.uint32(18).string(message.category);
    }
    if (message.severity !== "") {
      writer.uint32(26).string(message.severity);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.location !== "") {
      writer.uint32(42).string(message.location);
    }
    if (message.suggestion !== "") {
      writer.uint32(50).string(message.suggestion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Gap {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.category = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.severity = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.location = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.suggestion = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Gap {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      category: isSet(object.category) ? globalThis.String(object.category) : "",
      severity: isSet(object.severity) ? globalThis.String(object.severity) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      suggestion: isSet(object.suggestion) ? globalThis.String(object.suggestion) : "",
    };
  },

  toJSON(message: Gap): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.category !== "") {
      obj.category = message.category;
    }
    if (message.severity !== "") {
      obj.severity = message.severity;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.suggestion !== "") {
      obj.suggestion = message.suggestion;
    }
    return obj;
  },

  create(base?: DeepPartial<Gap>): Gap {
    return Gap.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Gap>): Gap {
    const message = createBaseGap();
    message.id = object.id ?? "";
    message.category = object.category ?? "";
    message.severity = object.severity ?? "";
    message.description = object.description ?? "";
    message.location = object.location ?? "";
    message.suggestion = object.suggestion ?? "";
    return message;
  },
};

function createBaseClarifyingQuestion(): ClarifyingQuestion {
  return { id: "", priority: "", category: "", question: "", context: "", suggestedAnswers: [], answer: "" };
}

export const ClarifyingQuestion: MessageFns<ClarifyingQuestion> = {
  encode(message: ClarifyingQuestion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.priority !== "") {
      writer.uint32(18).string(message.priority);
    }
    if (message.category !== "") {
      writer.uint32(26).string(message.category);
    }
    if (message.question !== "") {
      writer.uint32(34).string(message.question);
    }
    if (message.context !== "") {
      writer.uint32(42).string(message.context);
    }
    for (const v of message.suggestedAnswers) {
      writer.uint32(50).string(v!);
    }
    if (message.answer !== "") {
      writer.uint32(58).string(message.answer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClarifyingQuestion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClarifyingQuestion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.priority = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.category = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.question = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.context = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.suggestedAnswers.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.answer = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClarifyingQuestion {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      priority: isSet(object.priority) ? globalThis.String(object.priority) : "",
      category: isSet(object.category) ? globalThis.String(object.category) : "",
      question: isSet(object.question) ? globalThis.String(object.question) : "",
      context: isSet(object.context) ? globalThis.String(object.context) : "",
      suggestedAnswers: globalThis.Array.isArray(object?.suggestedAnswers)
        ? object.suggestedAnswers.map((e: any) => globalThis.String(e))
        : [],
      answer: isSet(object.answer) ? globalThis.String(object.answer) : "",
    };
  },

  toJSON(message: ClarifyingQuestion): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.priority !== "") {
      obj.priority = message.priority;
    }
    if (message.category !== "") {
      obj.category = message.category;
    }
    if (message.question !== "") {
      obj.question = message.question;
    }
    if (message.context !== "") {
      obj.context = message.context;
    }
    if (message.suggestedAnswers?.length) {
      obj.suggestedAnswers = message.suggestedAnswers;
    }
    if (message.answer !== "") {
      obj.answer = message.answer;
    }
    return obj;
  },

  create(base?: DeepPartial<ClarifyingQuestion>): ClarifyingQuestion {
    return ClarifyingQuestion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClarifyingQuestion>): ClarifyingQuestion {
    const message = createBaseClarifyingQuestion();
    message.id = object.id ?? "";
    message.priority = object.priority ?? "";
    message.category = object.category ?? "";
    message.question = object.question ?? "";
    message.context = object.context ?? "";
    message.suggestedAnswers = object.suggestedAnswers?.map((e) => e) || [];
    message.answer = object.answer ?? "";
    return message;
  },
};

function createBaseGeneratedAC(): GeneratedAC {
  return { id: "", source: "", confidence: 0, text: "", gherkin: "", accepted: false };
}

export const GeneratedAC: MessageFns<GeneratedAC> = {
  encode(message: GeneratedAC, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.source !== "") {
      writer.uint32(18).string(message.source);
    }
    if (message.confidence !== 0) {
      writer.uint32(29).float(message.confidence);
    }
    if (message.text !== "") {
      writer.uint32(34).string(message.text);
    }
    if (message.gherkin !== "") {
      writer.uint32(42).string(message.gherkin);
    }
    if (message.accepted !== false) {
      writer.uint32(48).bool(message.accepted);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeneratedAC {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeneratedAC();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.confidence = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.gherkin = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.accepted = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GeneratedAC {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      gherkin: isSet(object.gherkin) ? globalThis.String(object.gherkin) : "",
      accepted: isSet(object.accepted) ? globalThis.Boolean(object.accepted) : false,
    };
  },

  toJSON(message: GeneratedAC): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.gherkin !== "") {
      obj.gherkin = message.gherkin;
    }
    if (message.accepted !== false) {
      obj.accepted = message.accepted;
    }
    return obj;
  },

  create(base?: DeepPartial<GeneratedAC>): GeneratedAC {
    return GeneratedAC.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GeneratedAC>): GeneratedAC {
    const message = createBaseGeneratedAC();
    message.id = object.id ?? "";
    message.source = object.source ?? "";
    message.confidence = object.confidence ?? 0;
    message.text = object.text ?? "";
    message.gherkin = object.gherkin ?? "";
    message.accepted = object.accepted ?? false;
    return message;
  },
};

function createBaseDomainValidation(): DomainValidation {
  return { valid: false, entitiesFound: [], rulesApplicable: [], warnings: [] };
}

export const DomainValidation: MessageFns<DomainValidation> = {
  encode(message: DomainValidation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.valid !== false) {
      writer.uint32(8).bool(message.valid);
    }
    for (const v of message.entitiesFound) {
      EntityMapping.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.rulesApplicable) {
      ApplicableRule.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.warnings) {
      DomainWarning.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DomainValidation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDomainValidation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.valid = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.entitiesFound.push(EntityMapping.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rulesApplicable.push(ApplicableRule.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.warnings.push(DomainWarning.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DomainValidation {
    return {
      valid: isSet(object.valid) ? globalThis.Boolean(object.valid) : false,
      entitiesFound: globalThis.Array.isArray(object?.entitiesFound)
        ? object.entitiesFound.map((e: any) => EntityMapping.fromJSON(e))
        : [],
      rulesApplicable: globalThis.Array.isArray(object?.rulesApplicable)
        ? object.rulesApplicable.map((e: any) => ApplicableRule.fromJSON(e))
        : [],
      warnings: globalThis.Array.isArray(object?.warnings)
        ? object.warnings.map((e: any) => DomainWarning.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DomainValidation): unknown {
    const obj: any = {};
    if (message.valid !== false) {
      obj.valid = message.valid;
    }
    if (message.entitiesFound?.length) {
      obj.entitiesFound = message.entitiesFound.map((e) => EntityMapping.toJSON(e));
    }
    if (message.rulesApplicable?.length) {
      obj.rulesApplicable = message.rulesApplicable.map((e) => ApplicableRule.toJSON(e));
    }
    if (message.warnings?.length) {
      obj.warnings = message.warnings.map((e) => DomainWarning.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<DomainValidation>): DomainValidation {
    return DomainValidation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DomainValidation>): DomainValidation {
    const message = createBaseDomainValidation();
    message.valid = object.valid ?? false;
    message.entitiesFound = object.entitiesFound?.map((e) => EntityMapping.fromPartial(e)) || [];
    message.rulesApplicable = object.rulesApplicable?.map((e) => ApplicableRule.fromPartial(e)) || [];
    message.warnings = object.warnings?.map((e) => DomainWarning.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEntityMapping(): EntityMapping {
  return { term: "", mappedEntity: "", confidence: 0, domainDescription: "" };
}

export const EntityMapping: MessageFns<EntityMapping> = {
  encode(message: EntityMapping, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.term !== "") {
      writer.uint32(10).string(message.term);
    }
    if (message.mappedEntity !== "") {
      writer.uint32(18).string(message.mappedEntity);
    }
    if (message.confidence !== 0) {
      writer.uint32(29).float(message.confidence);
    }
    if (message.domainDescription !== "") {
      writer.uint32(34).string(message.domainDescription);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EntityMapping {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntityMapping();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.term = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mappedEntity = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.confidence = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.domainDescription = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EntityMapping {
    return {
      term: isSet(object.term) ? globalThis.String(object.term) : "",
      mappedEntity: isSet(object.mappedEntity) ? globalThis.String(object.mappedEntity) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
      domainDescription: isSet(object.domainDescription) ? globalThis.String(object.domainDescription) : "",
    };
  },

  toJSON(message: EntityMapping): unknown {
    const obj: any = {};
    if (message.term !== "") {
      obj.term = message.term;
    }
    if (message.mappedEntity !== "") {
      obj.mappedEntity = message.mappedEntity;
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    if (message.domainDescription !== "") {
      obj.domainDescription = message.domainDescription;
    }
    return obj;
  },

  create(base?: DeepPartial<EntityMapping>): EntityMapping {
    return EntityMapping.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EntityMapping>): EntityMapping {
    const message = createBaseEntityMapping();
    message.term = object.term ?? "";
    message.mappedEntity = object.mappedEntity ?? "";
    message.confidence = object.confidence ?? 0;
    message.domainDescription = object.domainDescription ?? "";
    return message;
  },
};

function createBaseApplicableRule(): ApplicableRule {
  return { ruleId: "", rule: "", relevance: "" };
}

export const ApplicableRule: MessageFns<ApplicableRule> = {
  encode(message: ApplicableRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ruleId !== "") {
      writer.uint32(10).string(message.ruleId);
    }
    if (message.rule !== "") {
      writer.uint32(18).string(message.rule);
    }
    if (message.relevance !== "") {
      writer.uint32(26).string(message.relevance);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApplicableRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplicableRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ruleId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rule = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.relevance = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApplicableRule {
    return {
      ruleId: isSet(object.ruleId) ? globalThis.String(object.ruleId) : "",
      rule: isSet(object.rule) ? globalThis.String(object.rule) : "",
      relevance: isSet(object.relevance) ? globalThis.String(object.relevance) : "",
    };
  },

  toJSON(message: ApplicableRule): unknown {
    const obj: any = {};
    if (message.ruleId !== "") {
      obj.ruleId = message.ruleId;
    }
    if (message.rule !== "") {
      obj.rule = message.rule;
    }
    if (message.relevance !== "") {
      obj.relevance = message.relevance;
    }
    return obj;
  },

  create(base?: DeepPartial<ApplicableRule>): ApplicableRule {
    return ApplicableRule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApplicableRule>): ApplicableRule {
    const message = createBaseApplicableRule();
    message.ruleId = object.ruleId ?? "";
    message.rule = object.rule ?? "";
    message.relevance = object.relevance ?? "";
    return message;
  },
};

function createBaseDomainWarning(): DomainWarning {
  return { type: "", message: "", suggestion: "" };
}

export const DomainWarning: MessageFns<DomainWarning> = {
  encode(message: DomainWarning, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.suggestion !== "") {
      writer.uint32(26).string(message.suggestion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DomainWarning {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDomainWarning();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.suggestion = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DomainWarning {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      suggestion: isSet(object.suggestion) ? globalThis.String(object.suggestion) : "",
    };
  },

  toJSON(message: DomainWarning): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.suggestion !== "") {
      obj.suggestion = message.suggestion;
    }
    return obj;
  },

  create(base?: DeepPartial<DomainWarning>): DomainWarning {
    return DomainWarning.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DomainWarning>): DomainWarning {
    const message = createBaseDomainWarning();
    message.type = object.type ?? "";
    message.message = object.message ?? "";
    message.suggestion = object.suggestion ?? "";
    return message;
  },
};

function createBaseAnalysisMetadata(): AnalysisMetadata {
  return { llmProvider: "", llmModel: "", tokensUsed: 0, analysisTimeMs: 0, inputType: "", agentVersion: "" };
}

export const AnalysisMetadata: MessageFns<AnalysisMetadata> = {
  encode(message: AnalysisMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.llmProvider !== "") {
      writer.uint32(10).string(message.llmProvider);
    }
    if (message.llmModel !== "") {
      writer.uint32(18).string(message.llmModel);
    }
    if (message.tokensUsed !== 0) {
      writer.uint32(24).int32(message.tokensUsed);
    }
    if (message.analysisTimeMs !== 0) {
      writer.uint32(37).float(message.analysisTimeMs);
    }
    if (message.inputType !== "") {
      writer.uint32(42).string(message.inputType);
    }
    if (message.agentVersion !== "") {
      writer.uint32(50).string(message.agentVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalysisMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalysisMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.llmProvider = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.llmModel = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.tokensUsed = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.analysisTimeMs = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.inputType = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.agentVersion = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalysisMetadata {
    return {
      llmProvider: isSet(object.llmProvider) ? globalThis.String(object.llmProvider) : "",
      llmModel: isSet(object.llmModel) ? globalThis.String(object.llmModel) : "",
      tokensUsed: isSet(object.tokensUsed) ? globalThis.Number(object.tokensUsed) : 0,
      analysisTimeMs: isSet(object.analysisTimeMs) ? globalThis.Number(object.analysisTimeMs) : 0,
      inputType: isSet(object.inputType) ? globalThis.String(object.inputType) : "",
      agentVersion: isSet(object.agentVersion) ? globalThis.String(object.agentVersion) : "",
    };
  },

  toJSON(message: AnalysisMetadata): unknown {
    const obj: any = {};
    if (message.llmProvider !== "") {
      obj.llmProvider = message.llmProvider;
    }
    if (message.llmModel !== "") {
      obj.llmModel = message.llmModel;
    }
    if (message.tokensUsed !== 0) {
      obj.tokensUsed = Math.round(message.tokensUsed);
    }
    if (message.analysisTimeMs !== 0) {
      obj.analysisTimeMs = message.analysisTimeMs;
    }
    if (message.inputType !== "") {
      obj.inputType = message.inputType;
    }
    if (message.agentVersion !== "") {
      obj.agentVersion = message.agentVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<AnalysisMetadata>): AnalysisMetadata {
    return AnalysisMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnalysisMetadata>): AnalysisMetadata {
    const message = createBaseAnalysisMetadata();
    message.llmProvider = object.llmProvider ?? "";
    message.llmModel = object.llmModel ?? "";
    message.tokensUsed = object.tokensUsed ?? 0;
    message.analysisTimeMs = object.analysisTimeMs ?? 0;
    message.inputType = object.inputType ?? "";
    message.agentVersion = object.agentVersion ?? "";
    return message;
  },
};

function createBaseReanalyzeRequest(): ReanalyzeRequest {
  return {
    requestId: "",
    originalRequestId: "",
    updatedTitle: "",
    updatedDescription: "",
    updatedAcs: [],
    answeredQuestions: [],
    acDecisions: [],
    additionalContext: "",
    config: undefined,
  };
}

export const ReanalyzeRequest: MessageFns<ReanalyzeRequest> = {
  encode(message: ReanalyzeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.originalRequestId !== "") {
      writer.uint32(18).string(message.originalRequestId);
    }
    if (message.updatedTitle !== "") {
      writer.uint32(26).string(message.updatedTitle);
    }
    if (message.updatedDescription !== "") {
      writer.uint32(34).string(message.updatedDescription);
    }
    for (const v of message.updatedAcs) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.answeredQuestions) {
      AnsweredQuestion.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.acDecisions) {
      ACDecision.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.additionalContext !== "") {
      writer.uint32(66).string(message.additionalContext);
    }
    if (message.config !== undefined) {
      AnalysisConfig.encode(message.config, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReanalyzeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReanalyzeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.originalRequestId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updatedTitle = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.updatedDescription = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.updatedAcs.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.answeredQuestions.push(AnsweredQuestion.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.acDecisions.push(ACDecision.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.additionalContext = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.config = AnalysisConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReanalyzeRequest {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      originalRequestId: isSet(object.originalRequestId) ? globalThis.String(object.originalRequestId) : "",
      updatedTitle: isSet(object.updatedTitle) ? globalThis.String(object.updatedTitle) : "",
      updatedDescription: isSet(object.updatedDescription) ? globalThis.String(object.updatedDescription) : "",
      updatedAcs: globalThis.Array.isArray(object?.updatedAcs)
        ? object.updatedAcs.map((e: any) => globalThis.String(e))
        : [],
      answeredQuestions: globalThis.Array.isArray(object?.answeredQuestions)
        ? object.answeredQuestions.map((e: any) => AnsweredQuestion.fromJSON(e))
        : [],
      acDecisions: globalThis.Array.isArray(object?.acDecisions)
        ? object.acDecisions.map((e: any) => ACDecision.fromJSON(e))
        : [],
      additionalContext: isSet(object.additionalContext) ? globalThis.String(object.additionalContext) : "",
      config: isSet(object.config) ? AnalysisConfig.fromJSON(object.config) : undefined,
    };
  },

  toJSON(message: ReanalyzeRequest): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.originalRequestId !== "") {
      obj.originalRequestId = message.originalRequestId;
    }
    if (message.updatedTitle !== "") {
      obj.updatedTitle = message.updatedTitle;
    }
    if (message.updatedDescription !== "") {
      obj.updatedDescription = message.updatedDescription;
    }
    if (message.updatedAcs?.length) {
      obj.updatedAcs = message.updatedAcs;
    }
    if (message.answeredQuestions?.length) {
      obj.answeredQuestions = message.answeredQuestions.map((e) => AnsweredQuestion.toJSON(e));
    }
    if (message.acDecisions?.length) {
      obj.acDecisions = message.acDecisions.map((e) => ACDecision.toJSON(e));
    }
    if (message.additionalContext !== "") {
      obj.additionalContext = message.additionalContext;
    }
    if (message.config !== undefined) {
      obj.config = AnalysisConfig.toJSON(message.config);
    }
    return obj;
  },

  create(base?: DeepPartial<ReanalyzeRequest>): ReanalyzeRequest {
    return ReanalyzeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReanalyzeRequest>): ReanalyzeRequest {
    const message = createBaseReanalyzeRequest();
    message.requestId = object.requestId ?? "";
    message.originalRequestId = object.originalRequestId ?? "";
    message.updatedTitle = object.updatedTitle ?? "";
    message.updatedDescription = object.updatedDescription ?? "";
    message.updatedAcs = object.updatedAcs?.map((e) => e) || [];
    message.answeredQuestions = object.answeredQuestions?.map((e) => AnsweredQuestion.fromPartial(e)) || [];
    message.acDecisions = object.acDecisions?.map((e) => ACDecision.fromPartial(e)) || [];
    message.additionalContext = object.additionalContext ?? "";
    message.config = (object.config !== undefined && object.config !== null)
      ? AnalysisConfig.fromPartial(object.config)
      : undefined;
    return message;
  },
};

function createBaseAnsweredQuestion(): AnsweredQuestion {
  return { questionId: "", answer: "" };
}

export const AnsweredQuestion: MessageFns<AnsweredQuestion> = {
  encode(message: AnsweredQuestion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.questionId !== "") {
      writer.uint32(10).string(message.questionId);
    }
    if (message.answer !== "") {
      writer.uint32(18).string(message.answer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnsweredQuestion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnsweredQuestion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.questionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.answer = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnsweredQuestion {
    return {
      questionId: isSet(object.questionId) ? globalThis.String(object.questionId) : "",
      answer: isSet(object.answer) ? globalThis.String(object.answer) : "",
    };
  },

  toJSON(message: AnsweredQuestion): unknown {
    const obj: any = {};
    if (message.questionId !== "") {
      obj.questionId = message.questionId;
    }
    if (message.answer !== "") {
      obj.answer = message.answer;
    }
    return obj;
  },

  create(base?: DeepPartial<AnsweredQuestion>): AnsweredQuestion {
    return AnsweredQuestion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnsweredQuestion>): AnsweredQuestion {
    const message = createBaseAnsweredQuestion();
    message.questionId = object.questionId ?? "";
    message.answer = object.answer ?? "";
    return message;
  },
};

function createBaseACDecision(): ACDecision {
  return { acId: "", accepted: false, modifiedText: "" };
}

export const ACDecision: MessageFns<ACDecision> = {
  encode(message: ACDecision, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.acId !== "") {
      writer.uint32(10).string(message.acId);
    }
    if (message.accepted !== false) {
      writer.uint32(16).bool(message.accepted);
    }
    if (message.modifiedText !== "") {
      writer.uint32(26).string(message.modifiedText);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ACDecision {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseACDecision();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.acId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.accepted = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.modifiedText = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ACDecision {
    return {
      acId: isSet(object.acId) ? globalThis.String(object.acId) : "",
      accepted: isSet(object.accepted) ? globalThis.Boolean(object.accepted) : false,
      modifiedText: isSet(object.modifiedText) ? globalThis.String(object.modifiedText) : "",
    };
  },

  toJSON(message: ACDecision): unknown {
    const obj: any = {};
    if (message.acId !== "") {
      obj.acId = message.acId;
    }
    if (message.accepted !== false) {
      obj.accepted = message.accepted;
    }
    if (message.modifiedText !== "") {
      obj.modifiedText = message.modifiedText;
    }
    return obj;
  },

  create(base?: DeepPartial<ACDecision>): ACDecision {
    return ACDecision.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ACDecision>): ACDecision {
    const message = createBaseACDecision();
    message.acId = object.acId ?? "";
    message.accepted = object.accepted ?? false;
    message.modifiedText = object.modifiedText ?? "";
    return message;
  },
};

function createBaseExportRequest(): ExportRequest {
  return {
    requestId: "",
    analysisRequestId: "",
    format: "",
    includeRecommendations: false,
    includeGeneratedAcs: false,
  };
}

export const ExportRequest: MessageFns<ExportRequest> = {
  encode(message: ExportRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.analysisRequestId !== "") {
      writer.uint32(18).string(message.analysisRequestId);
    }
    if (message.format !== "") {
      writer.uint32(26).string(message.format);
    }
    if (message.includeRecommendations !== false) {
      writer.uint32(32).bool(message.includeRecommendations);
    }
    if (message.includeGeneratedAcs !== false) {
      writer.uint32(40).bool(message.includeGeneratedAcs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.analysisRequestId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.format = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.includeRecommendations = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.includeGeneratedAcs = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportRequest {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      analysisRequestId: isSet(object.analysisRequestId) ? globalThis.String(object.analysisRequestId) : "",
      format: isSet(object.format) ? globalThis.String(object.format) : "",
      includeRecommendations: isSet(object.includeRecommendations)
        ? globalThis.Boolean(object.includeRecommendations)
        : false,
      includeGeneratedAcs: isSet(object.includeGeneratedAcs) ? globalThis.Boolean(object.includeGeneratedAcs) : false,
    };
  },

  toJSON(message: ExportRequest): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.analysisRequestId !== "") {
      obj.analysisRequestId = message.analysisRequestId;
    }
    if (message.format !== "") {
      obj.format = message.format;
    }
    if (message.includeRecommendations !== false) {
      obj.includeRecommendations = message.includeRecommendations;
    }
    if (message.includeGeneratedAcs !== false) {
      obj.includeGeneratedAcs = message.includeGeneratedAcs;
    }
    return obj;
  },

  create(base?: DeepPartial<ExportRequest>): ExportRequest {
    return ExportRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportRequest>): ExportRequest {
    const message = createBaseExportRequest();
    message.requestId = object.requestId ?? "";
    message.analysisRequestId = object.analysisRequestId ?? "";
    message.format = object.format ?? "";
    message.includeRecommendations = object.includeRecommendations ?? false;
    message.includeGeneratedAcs = object.includeGeneratedAcs ?? false;
    return message;
  },
};

function createBaseExportResponse(): ExportResponse {
  return { requestId: "", success: false, format: "", content: "", filename: "", error: "" };
}

export const ExportResponse: MessageFns<ExportResponse> = {
  encode(message: ExportResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.format !== "") {
      writer.uint32(26).string(message.format);
    }
    if (message.content !== "") {
      writer.uint32(34).string(message.content);
    }
    if (message.filename !== "") {
      writer.uint32(42).string(message.filename);
    }
    if (message.error !== "") {
      writer.uint32(50).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.format = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.filename = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportResponse {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      format: isSet(object.format) ? globalThis.String(object.format) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      filename: isSet(object.filename) ? globalThis.String(object.filename) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: ExportResponse): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.format !== "") {
      obj.format = message.format;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.filename !== "") {
      obj.filename = message.filename;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create(base?: DeepPartial<ExportResponse>): ExportResponse {
    return ExportResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportResponse>): ExportResponse {
    const message = createBaseExportResponse();
    message.requestId = object.requestId ?? "";
    message.success = object.success ?? false;
    message.format = object.format ?? "";
    message.content = object.content ?? "";
    message.filename = object.filename ?? "";
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseForwardRequest(): ForwardRequest {
  return {
    requestId: "",
    analysisRequestId: "",
    includeGeneratedAcs: false,
    includeDomainContext: false,
    testCasesConfig: undefined,
  };
}

export const ForwardRequest: MessageFns<ForwardRequest> = {
  encode(message: ForwardRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.analysisRequestId !== "") {
      writer.uint32(18).string(message.analysisRequestId);
    }
    if (message.includeGeneratedAcs !== false) {
      writer.uint32(24).bool(message.includeGeneratedAcs);
    }
    if (message.includeDomainContext !== false) {
      writer.uint32(32).bool(message.includeDomainContext);
    }
    if (message.testCasesConfig !== undefined) {
      TestCasesConfig.encode(message.testCasesConfig, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForwardRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForwardRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.analysisRequestId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.includeGeneratedAcs = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.includeDomainContext = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.testCasesConfig = TestCasesConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForwardRequest {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      analysisRequestId: isSet(object.analysisRequestId) ? globalThis.String(object.analysisRequestId) : "",
      includeGeneratedAcs: isSet(object.includeGeneratedAcs) ? globalThis.Boolean(object.includeGeneratedAcs) : false,
      includeDomainContext: isSet(object.includeDomainContext)
        ? globalThis.Boolean(object.includeDomainContext)
        : false,
      testCasesConfig: isSet(object.testCasesConfig) ? TestCasesConfig.fromJSON(object.testCasesConfig) : undefined,
    };
  },

  toJSON(message: ForwardRequest): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.analysisRequestId !== "") {
      obj.analysisRequestId = message.analysisRequestId;
    }
    if (message.includeGeneratedAcs !== false) {
      obj.includeGeneratedAcs = message.includeGeneratedAcs;
    }
    if (message.includeDomainContext !== false) {
      obj.includeDomainContext = message.includeDomainContext;
    }
    if (message.testCasesConfig !== undefined) {
      obj.testCasesConfig = TestCasesConfig.toJSON(message.testCasesConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<ForwardRequest>): ForwardRequest {
    return ForwardRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ForwardRequest>): ForwardRequest {
    const message = createBaseForwardRequest();
    message.requestId = object.requestId ?? "";
    message.analysisRequestId = object.analysisRequestId ?? "";
    message.includeGeneratedAcs = object.includeGeneratedAcs ?? false;
    message.includeDomainContext = object.includeDomainContext ?? false;
    message.testCasesConfig = (object.testCasesConfig !== undefined && object.testCasesConfig !== null)
      ? TestCasesConfig.fromPartial(object.testCasesConfig)
      : undefined;
    return message;
  },
};

function createBaseTestCasesConfig(): TestCasesConfig {
  return {
    outputFormat: "",
    coverageLevel: "",
    testTypes: [],
    llmProvider: "",
    checkDuplicates: false,
    maxTestCases: 0,
  };
}

export const TestCasesConfig: MessageFns<TestCasesConfig> = {
  encode(message: TestCasesConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.outputFormat !== "") {
      writer.uint32(10).string(message.outputFormat);
    }
    if (message.coverageLevel !== "") {
      writer.uint32(18).string(message.coverageLevel);
    }
    for (const v of message.testTypes) {
      writer.uint32(26).string(v!);
    }
    if (message.llmProvider !== "") {
      writer.uint32(34).string(message.llmProvider);
    }
    if (message.checkDuplicates !== false) {
      writer.uint32(40).bool(message.checkDuplicates);
    }
    if (message.maxTestCases !== 0) {
      writer.uint32(48).int32(message.maxTestCases);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestCasesConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestCasesConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.outputFormat = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.coverageLevel = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.testTypes.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.llmProvider = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.checkDuplicates = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.maxTestCases = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestCasesConfig {
    return {
      outputFormat: isSet(object.outputFormat) ? globalThis.String(object.outputFormat) : "",
      coverageLevel: isSet(object.coverageLevel) ? globalThis.String(object.coverageLevel) : "",
      testTypes: globalThis.Array.isArray(object?.testTypes)
        ? object.testTypes.map((e: any) => globalThis.String(e))
        : [],
      llmProvider: isSet(object.llmProvider) ? globalThis.String(object.llmProvider) : "",
      checkDuplicates: isSet(object.checkDuplicates) ? globalThis.Boolean(object.checkDuplicates) : false,
      maxTestCases: isSet(object.maxTestCases) ? globalThis.Number(object.maxTestCases) : 0,
    };
  },

  toJSON(message: TestCasesConfig): unknown {
    const obj: any = {};
    if (message.outputFormat !== "") {
      obj.outputFormat = message.outputFormat;
    }
    if (message.coverageLevel !== "") {
      obj.coverageLevel = message.coverageLevel;
    }
    if (message.testTypes?.length) {
      obj.testTypes = message.testTypes;
    }
    if (message.llmProvider !== "") {
      obj.llmProvider = message.llmProvider;
    }
    if (message.checkDuplicates !== false) {
      obj.checkDuplicates = message.checkDuplicates;
    }
    if (message.maxTestCases !== 0) {
      obj.maxTestCases = Math.round(message.maxTestCases);
    }
    return obj;
  },

  create(base?: DeepPartial<TestCasesConfig>): TestCasesConfig {
    return TestCasesConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TestCasesConfig>): TestCasesConfig {
    const message = createBaseTestCasesConfig();
    message.outputFormat = object.outputFormat ?? "";
    message.coverageLevel = object.coverageLevel ?? "";
    message.testTypes = object.testTypes?.map((e) => e) || [];
    message.llmProvider = object.llmProvider ?? "";
    message.checkDuplicates = object.checkDuplicates ?? false;
    message.maxTestCases = object.maxTestCases ?? 0;
    return message;
  },
};

function createBaseForwardResponse(): ForwardResponse {
  return {
    requestId: "",
    success: false,
    testCasesRequestId: "",
    testCasesGenerated: 0,
    structuredRequirementJson: "",
    error: "",
  };
}

export const ForwardResponse: MessageFns<ForwardResponse> = {
  encode(message: ForwardResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.testCasesRequestId !== "") {
      writer.uint32(26).string(message.testCasesRequestId);
    }
    if (message.testCasesGenerated !== 0) {
      writer.uint32(32).int32(message.testCasesGenerated);
    }
    if (message.structuredRequirementJson !== "") {
      writer.uint32(42).string(message.structuredRequirementJson);
    }
    if (message.error !== "") {
      writer.uint32(50).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForwardResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForwardResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.testCasesRequestId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.testCasesGenerated = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.structuredRequirementJson = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForwardResponse {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      testCasesRequestId: isSet(object.testCasesRequestId) ? globalThis.String(object.testCasesRequestId) : "",
      testCasesGenerated: isSet(object.testCasesGenerated) ? globalThis.Number(object.testCasesGenerated) : 0,
      structuredRequirementJson: isSet(object.structuredRequirementJson)
        ? globalThis.String(object.structuredRequirementJson)
        : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: ForwardResponse): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.testCasesRequestId !== "") {
      obj.testCasesRequestId = message.testCasesRequestId;
    }
    if (message.testCasesGenerated !== 0) {
      obj.testCasesGenerated = Math.round(message.testCasesGenerated);
    }
    if (message.structuredRequirementJson !== "") {
      obj.structuredRequirementJson = message.structuredRequirementJson;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create(base?: DeepPartial<ForwardResponse>): ForwardResponse {
    return ForwardResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ForwardResponse>): ForwardResponse {
    const message = createBaseForwardResponse();
    message.requestId = object.requestId ?? "";
    message.success = object.success ?? false;
    message.testCasesRequestId = object.testCasesRequestId ?? "";
    message.testCasesGenerated = object.testCasesGenerated ?? 0;
    message.structuredRequirementJson = object.structuredRequirementJson ?? "";
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseHealthCheckRequest(): HealthCheckRequest {
  return {};
}

export const HealthCheckRequest: MessageFns<HealthCheckRequest> = {
  encode(_: HealthCheckRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): HealthCheckRequest {
    return {};
  },

  toJSON(_: HealthCheckRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<HealthCheckRequest>): HealthCheckRequest {
    return HealthCheckRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<HealthCheckRequest>): HealthCheckRequest {
    const message = createBaseHealthCheckRequest();
    return message;
  },
};

function createBaseHealthCheckResponse(): HealthCheckResponse {
  return { status: "", components: {} };
}

export const HealthCheckResponse: MessageFns<HealthCheckResponse> = {
  encode(message: HealthCheckResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    Object.entries(message.components).forEach(([key, value]) => {
      HealthCheckResponse_ComponentsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = HealthCheckResponse_ComponentsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.components[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheckResponse {
    return {
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      components: isObject(object.components)
        ? Object.entries(object.components).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: HealthCheckResponse): unknown {
    const obj: any = {};
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.components) {
      const entries = Object.entries(message.components);
      if (entries.length > 0) {
        obj.components = {};
        entries.forEach(([k, v]) => {
          obj.components[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<HealthCheckResponse>): HealthCheckResponse {
    return HealthCheckResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HealthCheckResponse>): HealthCheckResponse {
    const message = createBaseHealthCheckResponse();
    message.status = object.status ?? "";
    message.components = Object.entries(object.components ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseHealthCheckResponse_ComponentsEntry(): HealthCheckResponse_ComponentsEntry {
  return { key: "", value: "" };
}

export const HealthCheckResponse_ComponentsEntry: MessageFns<HealthCheckResponse_ComponentsEntry> = {
  encode(message: HealthCheckResponse_ComponentsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckResponse_ComponentsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckResponse_ComponentsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheckResponse_ComponentsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: HealthCheckResponse_ComponentsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<HealthCheckResponse_ComponentsEntry>): HealthCheckResponse_ComponentsEntry {
    return HealthCheckResponse_ComponentsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HealthCheckResponse_ComponentsEntry>): HealthCheckResponse_ComponentsEntry {
    const message = createBaseHealthCheckResponse_ComponentsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseStructuredRequirement(): StructuredRequirement {
  return {
    id: "",
    title: "",
    description: "",
    acceptanceCriteria: [],
    domain: "",
    entities: [],
    preconditions: [],
    additionalContext: "",
    qualityScore: 0,
    gapsAddressed: false,
    questionsAnswered: false,
  };
}

export const StructuredRequirement: MessageFns<StructuredRequirement> = {
  encode(message: StructuredRequirement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    for (const v of message.acceptanceCriteria) {
      writer.uint32(34).string(v!);
    }
    if (message.domain !== "") {
      writer.uint32(42).string(message.domain);
    }
    for (const v of message.entities) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.preconditions) {
      writer.uint32(58).string(v!);
    }
    if (message.additionalContext !== "") {
      writer.uint32(66).string(message.additionalContext);
    }
    if (message.qualityScore !== 0) {
      writer.uint32(72).int32(message.qualityScore);
    }
    if (message.gapsAddressed !== false) {
      writer.uint32(80).bool(message.gapsAddressed);
    }
    if (message.questionsAnswered !== false) {
      writer.uint32(88).bool(message.questionsAnswered);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StructuredRequirement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStructuredRequirement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.acceptanceCriteria.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.domain = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.entities.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.preconditions.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.additionalContext = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.qualityScore = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.gapsAddressed = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.questionsAnswered = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StructuredRequirement {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      acceptanceCriteria: globalThis.Array.isArray(object?.acceptanceCriteria)
        ? object.acceptanceCriteria.map((e: any) => globalThis.String(e))
        : [],
      domain: isSet(object.domain) ? globalThis.String(object.domain) : "",
      entities: globalThis.Array.isArray(object?.entities) ? object.entities.map((e: any) => globalThis.String(e)) : [],
      preconditions: globalThis.Array.isArray(object?.preconditions)
        ? object.preconditions.map((e: any) => globalThis.String(e))
        : [],
      additionalContext: isSet(object.additionalContext) ? globalThis.String(object.additionalContext) : "",
      qualityScore: isSet(object.qualityScore) ? globalThis.Number(object.qualityScore) : 0,
      gapsAddressed: isSet(object.gapsAddressed) ? globalThis.Boolean(object.gapsAddressed) : false,
      questionsAnswered: isSet(object.questionsAnswered) ? globalThis.Boolean(object.questionsAnswered) : false,
    };
  },

  toJSON(message: StructuredRequirement): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.acceptanceCriteria?.length) {
      obj.acceptanceCriteria = message.acceptanceCriteria;
    }
    if (message.domain !== "") {
      obj.domain = message.domain;
    }
    if (message.entities?.length) {
      obj.entities = message.entities;
    }
    if (message.preconditions?.length) {
      obj.preconditions = message.preconditions;
    }
    if (message.additionalContext !== "") {
      obj.additionalContext = message.additionalContext;
    }
    if (message.qualityScore !== 0) {
      obj.qualityScore = Math.round(message.qualityScore);
    }
    if (message.gapsAddressed !== false) {
      obj.gapsAddressed = message.gapsAddressed;
    }
    if (message.questionsAnswered !== false) {
      obj.questionsAnswered = message.questionsAnswered;
    }
    return obj;
  },

  create(base?: DeepPartial<StructuredRequirement>): StructuredRequirement {
    return StructuredRequirement.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StructuredRequirement>): StructuredRequirement {
    const message = createBaseStructuredRequirement();
    message.id = object.id ?? "";
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.acceptanceCriteria = object.acceptanceCriteria?.map((e) => e) || [];
    message.domain = object.domain ?? "";
    message.entities = object.entities?.map((e) => e) || [];
    message.preconditions = object.preconditions?.map((e) => e) || [];
    message.additionalContext = object.additionalContext ?? "";
    message.qualityScore = object.qualityScore ?? 0;
    message.gapsAddressed = object.gapsAddressed ?? false;
    message.questionsAnswered = object.questionsAnswered ?? false;
    return message;
  },
};

export type RequirementAnalysisServiceDefinition = typeof RequirementAnalysisServiceDefinition;
export const RequirementAnalysisServiceDefinition = {
  name: "RequirementAnalysisService",
  fullName: "requirementanalysis.v1.RequirementAnalysisService",
  methods: {
    /** Analyze a requirement from any input type (Jira, free-form, transcript) */
    analyzeRequirement: {
      name: "AnalyzeRequirement",
      requestType: AnalyzeRequest,
      requestStream: false,
      responseType: AnalyzeResponse,
      responseStream: false,
      options: {},
    },
    /** Re-analyze with updates (questions answered, edits made) */
    reanalyzeRequirement: {
      name: "ReanalyzeRequirement",
      requestType: ReanalyzeRequest,
      requestStream: false,
      responseType: AnalyzeResponse,
      responseStream: false,
      options: {},
    },
    /** Export analysis report in text or JSON format */
    exportAnalysis: {
      name: "ExportAnalysis",
      requestType: ExportRequest,
      requestStream: false,
      responseType: ExportResponse,
      responseStream: false,
      options: {},
    },
    /** Forward analyzed requirement to Test Cases Agent */
    forwardToTestCases: {
      name: "ForwardToTestCases",
      requestType: ForwardRequest,
      requestStream: false,
      responseType: ForwardResponse,
      responseStream: false,
      options: {},
    },
    /** Health check */
    healthCheck: {
      name: "HealthCheck",
      requestType: HealthCheckRequest,
      requestStream: false,
      responseType: HealthCheckResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface RequirementAnalysisServiceImplementation<CallContextExt = {}> {
  /** Analyze a requirement from any input type (Jira, free-form, transcript) */
  analyzeRequirement(
    request: AnalyzeRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AnalyzeResponse>>;
  /** Re-analyze with updates (questions answered, edits made) */
  reanalyzeRequirement(
    request: ReanalyzeRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AnalyzeResponse>>;
  /** Export analysis report in text or JSON format */
  exportAnalysis(request: ExportRequest, context: CallContext & CallContextExt): Promise<DeepPartial<ExportResponse>>;
  /** Forward analyzed requirement to Test Cases Agent */
  forwardToTestCases(
    request: ForwardRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ForwardResponse>>;
  /** Health check */
  healthCheck(
    request: HealthCheckRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<HealthCheckResponse>>;
}

export interface RequirementAnalysisServiceClient<CallOptionsExt = {}> {
  /** Analyze a requirement from any input type (Jira, free-form, transcript) */
  analyzeRequirement(
    request: DeepPartial<AnalyzeRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AnalyzeResponse>;
  /** Re-analyze with updates (questions answered, edits made) */
  reanalyzeRequirement(
    request: DeepPartial<ReanalyzeRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AnalyzeResponse>;
  /** Export analysis report in text or JSON format */
  exportAnalysis(request: DeepPartial<ExportRequest>, options?: CallOptions & CallOptionsExt): Promise<ExportResponse>;
  /** Forward analyzed requirement to Test Cases Agent */
  forwardToTestCases(
    request: DeepPartial<ForwardRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ForwardResponse>;
  /** Health check */
  healthCheck(
    request: DeepPartial<HealthCheckRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<HealthCheckResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}

// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.10.0
//   protoc               v4.25.3
// source: test_cases.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { CallContext, CallOptions } from "nice-grpc-common";

export const protobufPackage = "testcases.v1";

export enum OutputFormat {
  OUTPUT_FORMAT_UNSPECIFIED = 0,
  GHERKIN = 1,
  TRADITIONAL = 2,
  JSON = 3,
  UNRECOGNIZED = -1,
}

export function outputFormatFromJSON(object: any): OutputFormat {
  switch (object) {
    case 0:
    case "OUTPUT_FORMAT_UNSPECIFIED":
      return OutputFormat.OUTPUT_FORMAT_UNSPECIFIED;
    case 1:
    case "GHERKIN":
      return OutputFormat.GHERKIN;
    case 2:
    case "TRADITIONAL":
      return OutputFormat.TRADITIONAL;
    case 3:
    case "JSON":
      return OutputFormat.JSON;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OutputFormat.UNRECOGNIZED;
  }
}

export function outputFormatToJSON(object: OutputFormat): string {
  switch (object) {
    case OutputFormat.OUTPUT_FORMAT_UNSPECIFIED:
      return "OUTPUT_FORMAT_UNSPECIFIED";
    case OutputFormat.GHERKIN:
      return "GHERKIN";
    case OutputFormat.TRADITIONAL:
      return "TRADITIONAL";
    case OutputFormat.JSON:
      return "JSON";
    case OutputFormat.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CoverageLevel {
  COVERAGE_LEVEL_UNSPECIFIED = 0,
  /** QUICK - Happy path + critical negatives */
  QUICK = 1,
  /** STANDARD - Comprehensive functional + negative */
  STANDARD = 2,
  /** EXHAUSTIVE - All scenarios including edge cases */
  EXHAUSTIVE = 3,
  UNRECOGNIZED = -1,
}

export function coverageLevelFromJSON(object: any): CoverageLevel {
  switch (object) {
    case 0:
    case "COVERAGE_LEVEL_UNSPECIFIED":
      return CoverageLevel.COVERAGE_LEVEL_UNSPECIFIED;
    case 1:
    case "QUICK":
      return CoverageLevel.QUICK;
    case 2:
    case "STANDARD":
      return CoverageLevel.STANDARD;
    case 3:
    case "EXHAUSTIVE":
      return CoverageLevel.EXHAUSTIVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CoverageLevel.UNRECOGNIZED;
  }
}

export function coverageLevelToJSON(object: CoverageLevel): string {
  switch (object) {
    case CoverageLevel.COVERAGE_LEVEL_UNSPECIFIED:
      return "COVERAGE_LEVEL_UNSPECIFIED";
    case CoverageLevel.QUICK:
      return "QUICK";
    case CoverageLevel.STANDARD:
      return "STANDARD";
    case CoverageLevel.EXHAUSTIVE:
      return "EXHAUSTIVE";
    case CoverageLevel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TestType {
  TEST_TYPE_UNSPECIFIED = 0,
  /** FUNCTIONAL - Happy path, expected behavior */
  FUNCTIONAL = 1,
  /** NEGATIVE - Invalid inputs, error handling */
  NEGATIVE = 2,
  /** BOUNDARY - Min/max values, limits */
  BOUNDARY = 3,
  /** EDGE_CASE - Unusual scenarios */
  EDGE_CASE = 4,
  /** SECURITY - Security-related tests */
  SECURITY = 5,
  /** PERFORMANCE - Performance hints/scenarios */
  PERFORMANCE = 6,
  /** INTEGRATION - Integration between components */
  INTEGRATION = 7,
  /** UNIT - Unit level tests */
  UNIT = 8,
  /** USABILITY - Usability and UX tests */
  USABILITY = 9,
  /** REGRESSION - Regression tests */
  REGRESSION = 10,
  /** SMOKE - Smoke tests */
  SMOKE = 11,
  /** ACCEPTANCE - Acceptance tests */
  ACCEPTANCE = 12,
  /** COMPATIBILITY - Compatibility tests */
  COMPATIBILITY = 13,
  /** ACCESSIBILITY - Accessibility tests */
  ACCESSIBILITY = 14,
  /** LOCALIZATION - Localization tests */
  LOCALIZATION = 15,
  /** API - API tests */
  API = 16,
  /** DATABASE - Database tests */
  DATABASE = 17,
  /** LOAD - Load tests */
  LOAD = 18,
  /** STRESS - Stress tests */
  STRESS = 19,
  /** RECOVERY - Recovery tests */
  RECOVERY = 20,
  UNRECOGNIZED = -1,
}

export function testTypeFromJSON(object: any): TestType {
  switch (object) {
    case 0:
    case "TEST_TYPE_UNSPECIFIED":
      return TestType.TEST_TYPE_UNSPECIFIED;
    case 1:
    case "FUNCTIONAL":
      return TestType.FUNCTIONAL;
    case 2:
    case "NEGATIVE":
      return TestType.NEGATIVE;
    case 3:
    case "BOUNDARY":
      return TestType.BOUNDARY;
    case 4:
    case "EDGE_CASE":
      return TestType.EDGE_CASE;
    case 5:
    case "SECURITY":
      return TestType.SECURITY;
    case 6:
    case "PERFORMANCE":
      return TestType.PERFORMANCE;
    case 7:
    case "INTEGRATION":
      return TestType.INTEGRATION;
    case 8:
    case "UNIT":
      return TestType.UNIT;
    case 9:
    case "USABILITY":
      return TestType.USABILITY;
    case 10:
    case "REGRESSION":
      return TestType.REGRESSION;
    case 11:
    case "SMOKE":
      return TestType.SMOKE;
    case 12:
    case "ACCEPTANCE":
      return TestType.ACCEPTANCE;
    case 13:
    case "COMPATIBILITY":
      return TestType.COMPATIBILITY;
    case 14:
    case "ACCESSIBILITY":
      return TestType.ACCESSIBILITY;
    case 15:
    case "LOCALIZATION":
      return TestType.LOCALIZATION;
    case 16:
    case "API":
      return TestType.API;
    case 17:
    case "DATABASE":
      return TestType.DATABASE;
    case 18:
    case "LOAD":
      return TestType.LOAD;
    case 19:
    case "STRESS":
      return TestType.STRESS;
    case 20:
    case "RECOVERY":
      return TestType.RECOVERY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TestType.UNRECOGNIZED;
  }
}

export function testTypeToJSON(object: TestType): string {
  switch (object) {
    case TestType.TEST_TYPE_UNSPECIFIED:
      return "TEST_TYPE_UNSPECIFIED";
    case TestType.FUNCTIONAL:
      return "FUNCTIONAL";
    case TestType.NEGATIVE:
      return "NEGATIVE";
    case TestType.BOUNDARY:
      return "BOUNDARY";
    case TestType.EDGE_CASE:
      return "EDGE_CASE";
    case TestType.SECURITY:
      return "SECURITY";
    case TestType.PERFORMANCE:
      return "PERFORMANCE";
    case TestType.INTEGRATION:
      return "INTEGRATION";
    case TestType.UNIT:
      return "UNIT";
    case TestType.USABILITY:
      return "USABILITY";
    case TestType.REGRESSION:
      return "REGRESSION";
    case TestType.SMOKE:
      return "SMOKE";
    case TestType.ACCEPTANCE:
      return "ACCEPTANCE";
    case TestType.COMPATIBILITY:
      return "COMPATIBILITY";
    case TestType.ACCESSIBILITY:
      return "ACCESSIBILITY";
    case TestType.LOCALIZATION:
      return "LOCALIZATION";
    case TestType.API:
      return "API";
    case TestType.DATABASE:
      return "DATABASE";
    case TestType.LOAD:
      return "LOAD";
    case TestType.STRESS:
      return "STRESS";
    case TestType.RECOVERY:
      return "RECOVERY";
    case TestType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Priority enum for test cases */
export enum Priority {
  PRIORITY_UNSPECIFIED = 0,
  /** CRITICAL - Must be tested, blocks release */
  CRITICAL = 1,
  /** HIGH - Important, should be tested */
  HIGH = 2,
  /** MEDIUM - Standard priority */
  MEDIUM = 3,
  /** LOW - Nice to have */
  LOW = 4,
  UNRECOGNIZED = -1,
}

export function priorityFromJSON(object: any): Priority {
  switch (object) {
    case 0:
    case "PRIORITY_UNSPECIFIED":
      return Priority.PRIORITY_UNSPECIFIED;
    case 1:
    case "CRITICAL":
      return Priority.CRITICAL;
    case 2:
    case "HIGH":
      return Priority.HIGH;
    case 3:
    case "MEDIUM":
      return Priority.MEDIUM;
    case 4:
    case "LOW":
      return Priority.LOW;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Priority.UNRECOGNIZED;
  }
}

export function priorityToJSON(object: Priority): string {
  switch (object) {
    case Priority.PRIORITY_UNSPECIFIED:
      return "PRIORITY_UNSPECIFIED";
    case Priority.CRITICAL:
      return "CRITICAL";
    case Priority.HIGH:
      return "HIGH";
    case Priority.MEDIUM:
      return "MEDIUM";
    case Priority.LOW:
      return "LOW";
    case Priority.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Test case status enum */
export enum TestCaseStatus {
  TEST_CASE_STATUS_UNSPECIFIED = 0,
  /** DRAFT - Test case is being created */
  DRAFT = 1,
  /** READY - Ready for execution */
  READY = 2,
  /** IN_PROGRESS - Currently being executed */
  IN_PROGRESS = 3,
  /** PASSED - Test passed */
  PASSED = 4,
  /** FAILED - Test failed */
  FAILED = 5,
  /** BLOCKED - Test is blocked */
  BLOCKED = 6,
  /** SKIPPED - Test was skipped */
  SKIPPED = 7,
  UNRECOGNIZED = -1,
}

export function testCaseStatusFromJSON(object: any): TestCaseStatus {
  switch (object) {
    case 0:
    case "TEST_CASE_STATUS_UNSPECIFIED":
      return TestCaseStatus.TEST_CASE_STATUS_UNSPECIFIED;
    case 1:
    case "DRAFT":
      return TestCaseStatus.DRAFT;
    case 2:
    case "READY":
      return TestCaseStatus.READY;
    case 3:
    case "IN_PROGRESS":
      return TestCaseStatus.IN_PROGRESS;
    case 4:
    case "PASSED":
      return TestCaseStatus.PASSED;
    case 5:
    case "FAILED":
      return TestCaseStatus.FAILED;
    case 6:
    case "BLOCKED":
      return TestCaseStatus.BLOCKED;
    case 7:
    case "SKIPPED":
      return TestCaseStatus.SKIPPED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TestCaseStatus.UNRECOGNIZED;
  }
}

export function testCaseStatusToJSON(object: TestCaseStatus): string {
  switch (object) {
    case TestCaseStatus.TEST_CASE_STATUS_UNSPECIFIED:
      return "TEST_CASE_STATUS_UNSPECIFIED";
    case TestCaseStatus.DRAFT:
      return "DRAFT";
    case TestCaseStatus.READY:
      return "READY";
    case TestCaseStatus.IN_PROGRESS:
      return "IN_PROGRESS";
    case TestCaseStatus.PASSED:
      return "PASSED";
    case TestCaseStatus.FAILED:
      return "FAILED";
    case TestCaseStatus.BLOCKED:
      return "BLOCKED";
    case TestCaseStatus.SKIPPED:
      return "SKIPPED";
    case TestCaseStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TestDataPlacement {
  TEST_DATA_PLACEMENT_UNSPECIFIED = 0,
  /** EMBEDDED - Data within test steps */
  EMBEDDED = 1,
  /** SEPARATE - Data in separate section */
  SEPARATE = 2,
  /** BOTH - Both embedded and separate */
  BOTH = 3,
  UNRECOGNIZED = -1,
}

export function testDataPlacementFromJSON(object: any): TestDataPlacement {
  switch (object) {
    case 0:
    case "TEST_DATA_PLACEMENT_UNSPECIFIED":
      return TestDataPlacement.TEST_DATA_PLACEMENT_UNSPECIFIED;
    case 1:
    case "EMBEDDED":
      return TestDataPlacement.EMBEDDED;
    case 2:
    case "SEPARATE":
      return TestDataPlacement.SEPARATE;
    case 3:
    case "BOTH":
      return TestDataPlacement.BOTH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TestDataPlacement.UNRECOGNIZED;
  }
}

export function testDataPlacementToJSON(object: TestDataPlacement): string {
  switch (object) {
    case TestDataPlacement.TEST_DATA_PLACEMENT_UNSPECIFIED:
      return "TEST_DATA_PLACEMENT_UNSPECIFIED";
    case TestDataPlacement.EMBEDDED:
      return "EMBEDDED";
    case TestDataPlacement.SEPARATE:
      return "SEPARATE";
    case TestDataPlacement.BOTH:
      return "BOTH";
    case TestDataPlacement.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Health check status enum */
export enum HealthCheckStatus {
  HEALTH_CHECK_STATUS_UNSPECIFIED = 0,
  /** SERVING - Service is healthy and serving */
  SERVING = 1,
  /** NOT_SERVING - Service is not serving */
  NOT_SERVING = 2,
  /** SERVICE_UNKNOWN - Service status unknown */
  SERVICE_UNKNOWN = 3,
  UNRECOGNIZED = -1,
}

export function healthCheckStatusFromJSON(object: any): HealthCheckStatus {
  switch (object) {
    case 0:
    case "HEALTH_CHECK_STATUS_UNSPECIFIED":
      return HealthCheckStatus.HEALTH_CHECK_STATUS_UNSPECIFIED;
    case 1:
    case "SERVING":
      return HealthCheckStatus.SERVING;
    case 2:
    case "NOT_SERVING":
      return HealthCheckStatus.NOT_SERVING;
    case 3:
    case "SERVICE_UNKNOWN":
      return HealthCheckStatus.SERVICE_UNKNOWN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HealthCheckStatus.UNRECOGNIZED;
  }
}

export function healthCheckStatusToJSON(object: HealthCheckStatus): string {
  switch (object) {
    case HealthCheckStatus.HEALTH_CHECK_STATUS_UNSPECIFIED:
      return "HEALTH_CHECK_STATUS_UNSPECIFIED";
    case HealthCheckStatus.SERVING:
      return "SERVING";
    case HealthCheckStatus.NOT_SERVING:
      return "NOT_SERVING";
    case HealthCheckStatus.SERVICE_UNKNOWN:
      return "SERVICE_UNKNOWN";
    case HealthCheckStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface GenerateTestCasesRequest {
  requestId: string;
  userStory?: UserStoryInput | undefined;
  apiSpec?: ApiSpecInput | undefined;
  freeForm?:
    | FreeFormInput
    | undefined;
  /** Domain enrichment (optional) */
  domainConfig:
    | DomainConfig
    | undefined;
  /** Generation configuration */
  generationConfig:
    | GenerationConfig
    | undefined;
  /** Test data configuration */
  testDataConfig: TestDataConfig | undefined;
}

export interface UserStoryInput {
  /** "As a customer, I want to..." */
  story: string;
  /** List of ACs */
  acceptanceCriteria: string[];
  /** Optional extra context */
  additionalContext: string;
}

export interface ApiSpecInput {
  /** OpenAPI/GraphQL spec (JSON/YAML string) */
  spec: string;
  /** openapi, graphql */
  specFormat: string;
  /** Specific endpoints to test (optional) */
  endpoints: string[];
}

export interface FreeFormInput {
  /** Free-form requirements text */
  requirement: string;
  /** Additional context as key-value pairs */
  context: { [key: string]: string };
}

export interface FreeFormInput_ContextEntry {
  key: string;
  value: string;
}

/** Also define FreeFormRequirement as an alias for compatibility */
export interface FreeFormRequirement {
  /** Free-form requirements text */
  requirementText: string;
  /** Additional context */
  contextInfo: { [key: string]: string };
}

export interface FreeFormRequirement_ContextInfoEntry {
  key: string;
  value: string;
}

export interface DomainConfig {
  /** ecommerce, supply_chain, etc. */
  domain: string;
  /** cart, order, payment, etc. */
  entity: string;
  /** checkout, return_flow, etc. */
  workflow: string;
  /** Fetch rules from Domain Agent */
  includeBusinessRules: boolean;
  /** Fetch edge cases from Domain Agent */
  includeEdgeCases: boolean;
}

export interface GenerationConfig {
  /** GHERKIN, TRADITIONAL, JSON */
  outputFormat: OutputFormat;
  /** QUICK, STANDARD, EXHAUSTIVE */
  coverageLevel: CoverageLevel;
  /** FUNCTIONAL, NEGATIVE, BOUNDARY, etc. */
  testTypes: TestType[];
  /** anthropic, openai, gemini (default: anthropic) */
  llmProvider: string;
  /** Check against existing test cases */
  checkDuplicates: boolean;
  /** Limit number of generated cases */
  maxTestCases: number;
  /** high, medium, low (focus on this priority) */
  priorityFocus: string;
  /** Number of test cases to generate */
  count: number;
  /** Include edge case tests */
  includeEdgeCases: boolean;
  /** Include negative tests */
  includeNegativeTests: boolean;
  /** low, medium, high detail level */
  detailLevel: string;
}

export interface TestDataConfig {
  /** Request sample data from Test Data Agent */
  generateTestData: boolean;
  /** EMBEDDED, SEPARATE, BOTH */
  placement: TestDataPlacement;
  /** Number of data samples per test case */
  samplesPerCase: number;
}

export interface GenerateTestCasesResponse {
  requestId: string;
  success: boolean;
  testCases: TestCase[];
  metadata: GenerationMetadata | undefined;
  errorMessage: string;
}

export interface TestCase {
  /** TC-001, TC-002, etc. */
  id: string;
  title: string;
  description: string;
  type: TestType;
  /** Priority enum */
  priority: Priority;
  tags: string[];
  /** Traceability */
  requirementId: string;
  /** Preconditions */
  preconditions: string[];
  /** Test steps (for TRADITIONAL format) */
  steps: TestStep[];
  /** Gherkin content (for GHERKIN format) */
  gherkin: string;
  /** Test data */
  testData:
    | TestData
    | undefined;
  /** Expected results summary */
  expectedResult: string;
  /** Postconditions */
  postconditions: string[];
  /** Test case status */
  status: TestCaseStatus;
}

export interface TestStep {
  order: number;
  action: string;
  expectedResult: string;
  /** Embedded test data (if EMBEDDED or BOTH) */
  testData: string;
}

export interface TestData {
  items: TestDataItem[];
}

export interface TestDataItem {
  field: string;
  value: string;
  description: string;
}

export interface GenerationMetadata {
  llmProvider: string;
  llmModel: string;
  llmTokensUsed: number;
  generationTimeMs: number;
  testCasesGenerated: number;
  duplicatesFound: number;
  coverage: CoverageAnalysis | undefined;
  domainContextUsed: string;
}

export interface CoverageAnalysis {
  functionalCount: number;
  negativeCount: number;
  boundaryCount: number;
  edgeCaseCount: number;
  /** Areas that might need more coverage */
  uncoveredAreas: string[];
}

export interface GetTestCaseRequest {
  testCaseId: string;
}

export interface GetTestCaseResponse {
  testCase: TestCase | undefined;
}

export interface ListTestCasesRequest {
  /** Filter by domain */
  domain: string;
  /** Filter by entity */
  entity: string;
  /** Filter by test type */
  type: TestType;
  /** Semantic search */
  searchQuery: string;
  limit: number;
  offset: number;
}

export interface ListTestCasesResponse {
  testCases: TestCaseSummary[];
  totalCount: number;
}

export interface TestCaseSummary {
  id: string;
  title: string;
  type: TestType;
  priority: Priority;
  domain: string;
  entity: string;
  createdAt: string;
}

export interface StoreTestCasesRequest {
  testCases: TestCase[];
  domain: string;
  entity: string;
  /** manual, generated, imported */
  source: string;
}

export interface StoreTestCasesResponse {
  success: boolean;
  storedCount: number;
  error: string;
}

export interface AnalyzeCoverageRequest {
  requestId: string;
  userStory?: UserStoryInput | undefined;
  apiSpec?:
    | ApiSpecInput
    | undefined;
  /** IDs of existing cases to check against */
  existingTestCaseIds: string[];
}

export interface AnalyzeCoverageResponse {
  requestId: string;
  report: CoverageReport | undefined;
}

export interface CoverageReport {
  /** 0.0 - 1.0 */
  overallCoverage: number;
  gaps: CoverageGap[];
  recommendations: string[];
}

export interface CoverageGap {
  /** What's not covered */
  area: string;
  /** functional, negative, boundary */
  type: string;
  /** high, medium, low */
  severity: string;
  /** Suggested test case */
  suggestion: string;
}

export interface HealthCheckRequest {
}

export interface HealthCheckResponse {
  /** Service status enum */
  status: HealthCheckStatus;
  /** Service version */
  version: string;
  /** Component status */
  components: { [key: string]: string };
}

export interface HealthCheckResponse_ComponentsEntry {
  key: string;
  value: string;
}

function createBaseGenerateTestCasesRequest(): GenerateTestCasesRequest {
  return {
    requestId: "",
    userStory: undefined,
    apiSpec: undefined,
    freeForm: undefined,
    domainConfig: undefined,
    generationConfig: undefined,
    testDataConfig: undefined,
  };
}

export const GenerateTestCasesRequest: MessageFns<GenerateTestCasesRequest> = {
  encode(message: GenerateTestCasesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.userStory !== undefined) {
      UserStoryInput.encode(message.userStory, writer.uint32(18).fork()).join();
    }
    if (message.apiSpec !== undefined) {
      ApiSpecInput.encode(message.apiSpec, writer.uint32(26).fork()).join();
    }
    if (message.freeForm !== undefined) {
      FreeFormInput.encode(message.freeForm, writer.uint32(34).fork()).join();
    }
    if (message.domainConfig !== undefined) {
      DomainConfig.encode(message.domainConfig, writer.uint32(42).fork()).join();
    }
    if (message.generationConfig !== undefined) {
      GenerationConfig.encode(message.generationConfig, writer.uint32(50).fork()).join();
    }
    if (message.testDataConfig !== undefined) {
      TestDataConfig.encode(message.testDataConfig, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateTestCasesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateTestCasesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userStory = UserStoryInput.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.apiSpec = ApiSpecInput.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.freeForm = FreeFormInput.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.domainConfig = DomainConfig.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.generationConfig = GenerationConfig.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.testDataConfig = TestDataConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateTestCasesRequest {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      userStory: isSet(object.userStory) ? UserStoryInput.fromJSON(object.userStory) : undefined,
      apiSpec: isSet(object.apiSpec) ? ApiSpecInput.fromJSON(object.apiSpec) : undefined,
      freeForm: isSet(object.freeForm) ? FreeFormInput.fromJSON(object.freeForm) : undefined,
      domainConfig: isSet(object.domainConfig) ? DomainConfig.fromJSON(object.domainConfig) : undefined,
      generationConfig: isSet(object.generationConfig) ? GenerationConfig.fromJSON(object.generationConfig) : undefined,
      testDataConfig: isSet(object.testDataConfig) ? TestDataConfig.fromJSON(object.testDataConfig) : undefined,
    };
  },

  toJSON(message: GenerateTestCasesRequest): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.userStory !== undefined) {
      obj.userStory = UserStoryInput.toJSON(message.userStory);
    }
    if (message.apiSpec !== undefined) {
      obj.apiSpec = ApiSpecInput.toJSON(message.apiSpec);
    }
    if (message.freeForm !== undefined) {
      obj.freeForm = FreeFormInput.toJSON(message.freeForm);
    }
    if (message.domainConfig !== undefined) {
      obj.domainConfig = DomainConfig.toJSON(message.domainConfig);
    }
    if (message.generationConfig !== undefined) {
      obj.generationConfig = GenerationConfig.toJSON(message.generationConfig);
    }
    if (message.testDataConfig !== undefined) {
      obj.testDataConfig = TestDataConfig.toJSON(message.testDataConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateTestCasesRequest>): GenerateTestCasesRequest {
    return GenerateTestCasesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateTestCasesRequest>): GenerateTestCasesRequest {
    const message = createBaseGenerateTestCasesRequest();
    message.requestId = object.requestId ?? "";
    message.userStory = (object.userStory !== undefined && object.userStory !== null)
      ? UserStoryInput.fromPartial(object.userStory)
      : undefined;
    message.apiSpec = (object.apiSpec !== undefined && object.apiSpec !== null)
      ? ApiSpecInput.fromPartial(object.apiSpec)
      : undefined;
    message.freeForm = (object.freeForm !== undefined && object.freeForm !== null)
      ? FreeFormInput.fromPartial(object.freeForm)
      : undefined;
    message.domainConfig = (object.domainConfig !== undefined && object.domainConfig !== null)
      ? DomainConfig.fromPartial(object.domainConfig)
      : undefined;
    message.generationConfig = (object.generationConfig !== undefined && object.generationConfig !== null)
      ? GenerationConfig.fromPartial(object.generationConfig)
      : undefined;
    message.testDataConfig = (object.testDataConfig !== undefined && object.testDataConfig !== null)
      ? TestDataConfig.fromPartial(object.testDataConfig)
      : undefined;
    return message;
  },
};

function createBaseUserStoryInput(): UserStoryInput {
  return { story: "", acceptanceCriteria: [], additionalContext: "" };
}

export const UserStoryInput: MessageFns<UserStoryInput> = {
  encode(message: UserStoryInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.story !== "") {
      writer.uint32(10).string(message.story);
    }
    for (const v of message.acceptanceCriteria) {
      writer.uint32(18).string(v!);
    }
    if (message.additionalContext !== "") {
      writer.uint32(26).string(message.additionalContext);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserStoryInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserStoryInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.story = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.acceptanceCriteria.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.additionalContext = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserStoryInput {
    return {
      story: isSet(object.story) ? globalThis.String(object.story) : "",
      acceptanceCriteria: globalThis.Array.isArray(object?.acceptanceCriteria)
        ? object.acceptanceCriteria.map((e: any) => globalThis.String(e))
        : [],
      additionalContext: isSet(object.additionalContext) ? globalThis.String(object.additionalContext) : "",
    };
  },

  toJSON(message: UserStoryInput): unknown {
    const obj: any = {};
    if (message.story !== "") {
      obj.story = message.story;
    }
    if (message.acceptanceCriteria?.length) {
      obj.acceptanceCriteria = message.acceptanceCriteria;
    }
    if (message.additionalContext !== "") {
      obj.additionalContext = message.additionalContext;
    }
    return obj;
  },

  create(base?: DeepPartial<UserStoryInput>): UserStoryInput {
    return UserStoryInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserStoryInput>): UserStoryInput {
    const message = createBaseUserStoryInput();
    message.story = object.story ?? "";
    message.acceptanceCriteria = object.acceptanceCriteria?.map((e) => e) || [];
    message.additionalContext = object.additionalContext ?? "";
    return message;
  },
};

function createBaseApiSpecInput(): ApiSpecInput {
  return { spec: "", specFormat: "", endpoints: [] };
}

export const ApiSpecInput: MessageFns<ApiSpecInput> = {
  encode(message: ApiSpecInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.spec !== "") {
      writer.uint32(10).string(message.spec);
    }
    if (message.specFormat !== "") {
      writer.uint32(18).string(message.specFormat);
    }
    for (const v of message.endpoints) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApiSpecInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApiSpecInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.spec = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.specFormat = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.endpoints.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApiSpecInput {
    return {
      spec: isSet(object.spec) ? globalThis.String(object.spec) : "",
      specFormat: isSet(object.specFormat) ? globalThis.String(object.specFormat) : "",
      endpoints: globalThis.Array.isArray(object?.endpoints)
        ? object.endpoints.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ApiSpecInput): unknown {
    const obj: any = {};
    if (message.spec !== "") {
      obj.spec = message.spec;
    }
    if (message.specFormat !== "") {
      obj.specFormat = message.specFormat;
    }
    if (message.endpoints?.length) {
      obj.endpoints = message.endpoints;
    }
    return obj;
  },

  create(base?: DeepPartial<ApiSpecInput>): ApiSpecInput {
    return ApiSpecInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApiSpecInput>): ApiSpecInput {
    const message = createBaseApiSpecInput();
    message.spec = object.spec ?? "";
    message.specFormat = object.specFormat ?? "";
    message.endpoints = object.endpoints?.map((e) => e) || [];
    return message;
  },
};

function createBaseFreeFormInput(): FreeFormInput {
  return { requirement: "", context: {} };
}

export const FreeFormInput: MessageFns<FreeFormInput> = {
  encode(message: FreeFormInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requirement !== "") {
      writer.uint32(10).string(message.requirement);
    }
    Object.entries(message.context).forEach(([key, value]) => {
      FreeFormInput_ContextEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FreeFormInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFreeFormInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requirement = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = FreeFormInput_ContextEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.context[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FreeFormInput {
    return {
      requirement: isSet(object.requirement) ? globalThis.String(object.requirement) : "",
      context: isObject(object.context)
        ? Object.entries(object.context).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: FreeFormInput): unknown {
    const obj: any = {};
    if (message.requirement !== "") {
      obj.requirement = message.requirement;
    }
    if (message.context) {
      const entries = Object.entries(message.context);
      if (entries.length > 0) {
        obj.context = {};
        entries.forEach(([k, v]) => {
          obj.context[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<FreeFormInput>): FreeFormInput {
    return FreeFormInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FreeFormInput>): FreeFormInput {
    const message = createBaseFreeFormInput();
    message.requirement = object.requirement ?? "";
    message.context = Object.entries(object.context ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseFreeFormInput_ContextEntry(): FreeFormInput_ContextEntry {
  return { key: "", value: "" };
}

export const FreeFormInput_ContextEntry: MessageFns<FreeFormInput_ContextEntry> = {
  encode(message: FreeFormInput_ContextEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FreeFormInput_ContextEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFreeFormInput_ContextEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FreeFormInput_ContextEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: FreeFormInput_ContextEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<FreeFormInput_ContextEntry>): FreeFormInput_ContextEntry {
    return FreeFormInput_ContextEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FreeFormInput_ContextEntry>): FreeFormInput_ContextEntry {
    const message = createBaseFreeFormInput_ContextEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseFreeFormRequirement(): FreeFormRequirement {
  return { requirementText: "", contextInfo: {} };
}

export const FreeFormRequirement: MessageFns<FreeFormRequirement> = {
  encode(message: FreeFormRequirement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requirementText !== "") {
      writer.uint32(10).string(message.requirementText);
    }
    Object.entries(message.contextInfo).forEach(([key, value]) => {
      FreeFormRequirement_ContextInfoEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FreeFormRequirement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFreeFormRequirement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requirementText = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = FreeFormRequirement_ContextInfoEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.contextInfo[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FreeFormRequirement {
    return {
      requirementText: isSet(object.requirementText) ? globalThis.String(object.requirementText) : "",
      contextInfo: isObject(object.contextInfo)
        ? Object.entries(object.contextInfo).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: FreeFormRequirement): unknown {
    const obj: any = {};
    if (message.requirementText !== "") {
      obj.requirementText = message.requirementText;
    }
    if (message.contextInfo) {
      const entries = Object.entries(message.contextInfo);
      if (entries.length > 0) {
        obj.contextInfo = {};
        entries.forEach(([k, v]) => {
          obj.contextInfo[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<FreeFormRequirement>): FreeFormRequirement {
    return FreeFormRequirement.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FreeFormRequirement>): FreeFormRequirement {
    const message = createBaseFreeFormRequirement();
    message.requirementText = object.requirementText ?? "";
    message.contextInfo = Object.entries(object.contextInfo ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseFreeFormRequirement_ContextInfoEntry(): FreeFormRequirement_ContextInfoEntry {
  return { key: "", value: "" };
}

export const FreeFormRequirement_ContextInfoEntry: MessageFns<FreeFormRequirement_ContextInfoEntry> = {
  encode(message: FreeFormRequirement_ContextInfoEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FreeFormRequirement_ContextInfoEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFreeFormRequirement_ContextInfoEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FreeFormRequirement_ContextInfoEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: FreeFormRequirement_ContextInfoEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<FreeFormRequirement_ContextInfoEntry>): FreeFormRequirement_ContextInfoEntry {
    return FreeFormRequirement_ContextInfoEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FreeFormRequirement_ContextInfoEntry>): FreeFormRequirement_ContextInfoEntry {
    const message = createBaseFreeFormRequirement_ContextInfoEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseDomainConfig(): DomainConfig {
  return { domain: "", entity: "", workflow: "", includeBusinessRules: false, includeEdgeCases: false };
}

export const DomainConfig: MessageFns<DomainConfig> = {
  encode(message: DomainConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.domain !== "") {
      writer.uint32(10).string(message.domain);
    }
    if (message.entity !== "") {
      writer.uint32(18).string(message.entity);
    }
    if (message.workflow !== "") {
      writer.uint32(26).string(message.workflow);
    }
    if (message.includeBusinessRules !== false) {
      writer.uint32(32).bool(message.includeBusinessRules);
    }
    if (message.includeEdgeCases !== false) {
      writer.uint32(40).bool(message.includeEdgeCases);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DomainConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDomainConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.domain = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.entity = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.workflow = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.includeBusinessRules = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.includeEdgeCases = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DomainConfig {
    return {
      domain: isSet(object.domain) ? globalThis.String(object.domain) : "",
      entity: isSet(object.entity) ? globalThis.String(object.entity) : "",
      workflow: isSet(object.workflow) ? globalThis.String(object.workflow) : "",
      includeBusinessRules: isSet(object.includeBusinessRules)
        ? globalThis.Boolean(object.includeBusinessRules)
        : false,
      includeEdgeCases: isSet(object.includeEdgeCases) ? globalThis.Boolean(object.includeEdgeCases) : false,
    };
  },

  toJSON(message: DomainConfig): unknown {
    const obj: any = {};
    if (message.domain !== "") {
      obj.domain = message.domain;
    }
    if (message.entity !== "") {
      obj.entity = message.entity;
    }
    if (message.workflow !== "") {
      obj.workflow = message.workflow;
    }
    if (message.includeBusinessRules !== false) {
      obj.includeBusinessRules = message.includeBusinessRules;
    }
    if (message.includeEdgeCases !== false) {
      obj.includeEdgeCases = message.includeEdgeCases;
    }
    return obj;
  },

  create(base?: DeepPartial<DomainConfig>): DomainConfig {
    return DomainConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DomainConfig>): DomainConfig {
    const message = createBaseDomainConfig();
    message.domain = object.domain ?? "";
    message.entity = object.entity ?? "";
    message.workflow = object.workflow ?? "";
    message.includeBusinessRules = object.includeBusinessRules ?? false;
    message.includeEdgeCases = object.includeEdgeCases ?? false;
    return message;
  },
};

function createBaseGenerationConfig(): GenerationConfig {
  return {
    outputFormat: 0,
    coverageLevel: 0,
    testTypes: [],
    llmProvider: "",
    checkDuplicates: false,
    maxTestCases: 0,
    priorityFocus: "",
    count: 0,
    includeEdgeCases: false,
    includeNegativeTests: false,
    detailLevel: "",
  };
}

export const GenerationConfig: MessageFns<GenerationConfig> = {
  encode(message: GenerationConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.outputFormat !== 0) {
      writer.uint32(8).int32(message.outputFormat);
    }
    if (message.coverageLevel !== 0) {
      writer.uint32(16).int32(message.coverageLevel);
    }
    writer.uint32(26).fork();
    for (const v of message.testTypes) {
      writer.int32(v);
    }
    writer.join();
    if (message.llmProvider !== "") {
      writer.uint32(34).string(message.llmProvider);
    }
    if (message.checkDuplicates !== false) {
      writer.uint32(40).bool(message.checkDuplicates);
    }
    if (message.maxTestCases !== 0) {
      writer.uint32(48).int32(message.maxTestCases);
    }
    if (message.priorityFocus !== "") {
      writer.uint32(58).string(message.priorityFocus);
    }
    if (message.count !== 0) {
      writer.uint32(64).int32(message.count);
    }
    if (message.includeEdgeCases !== false) {
      writer.uint32(72).bool(message.includeEdgeCases);
    }
    if (message.includeNegativeTests !== false) {
      writer.uint32(80).bool(message.includeNegativeTests);
    }
    if (message.detailLevel !== "") {
      writer.uint32(90).string(message.detailLevel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerationConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerationConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.outputFormat = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.coverageLevel = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag === 24) {
            message.testTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.testTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.llmProvider = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.checkDuplicates = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.maxTestCases = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.priorityFocus = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.count = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.includeEdgeCases = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.includeNegativeTests = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.detailLevel = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerationConfig {
    return {
      outputFormat: isSet(object.outputFormat) ? outputFormatFromJSON(object.outputFormat) : 0,
      coverageLevel: isSet(object.coverageLevel) ? coverageLevelFromJSON(object.coverageLevel) : 0,
      testTypes: globalThis.Array.isArray(object?.testTypes)
        ? object.testTypes.map((e: any) => testTypeFromJSON(e))
        : [],
      llmProvider: isSet(object.llmProvider) ? globalThis.String(object.llmProvider) : "",
      checkDuplicates: isSet(object.checkDuplicates) ? globalThis.Boolean(object.checkDuplicates) : false,
      maxTestCases: isSet(object.maxTestCases) ? globalThis.Number(object.maxTestCases) : 0,
      priorityFocus: isSet(object.priorityFocus) ? globalThis.String(object.priorityFocus) : "",
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
      includeEdgeCases: isSet(object.includeEdgeCases) ? globalThis.Boolean(object.includeEdgeCases) : false,
      includeNegativeTests: isSet(object.includeNegativeTests)
        ? globalThis.Boolean(object.includeNegativeTests)
        : false,
      detailLevel: isSet(object.detailLevel) ? globalThis.String(object.detailLevel) : "",
    };
  },

  toJSON(message: GenerationConfig): unknown {
    const obj: any = {};
    if (message.outputFormat !== 0) {
      obj.outputFormat = outputFormatToJSON(message.outputFormat);
    }
    if (message.coverageLevel !== 0) {
      obj.coverageLevel = coverageLevelToJSON(message.coverageLevel);
    }
    if (message.testTypes?.length) {
      obj.testTypes = message.testTypes.map((e) => testTypeToJSON(e));
    }
    if (message.llmProvider !== "") {
      obj.llmProvider = message.llmProvider;
    }
    if (message.checkDuplicates !== false) {
      obj.checkDuplicates = message.checkDuplicates;
    }
    if (message.maxTestCases !== 0) {
      obj.maxTestCases = Math.round(message.maxTestCases);
    }
    if (message.priorityFocus !== "") {
      obj.priorityFocus = message.priorityFocus;
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.includeEdgeCases !== false) {
      obj.includeEdgeCases = message.includeEdgeCases;
    }
    if (message.includeNegativeTests !== false) {
      obj.includeNegativeTests = message.includeNegativeTests;
    }
    if (message.detailLevel !== "") {
      obj.detailLevel = message.detailLevel;
    }
    return obj;
  },

  create(base?: DeepPartial<GenerationConfig>): GenerationConfig {
    return GenerationConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerationConfig>): GenerationConfig {
    const message = createBaseGenerationConfig();
    message.outputFormat = object.outputFormat ?? 0;
    message.coverageLevel = object.coverageLevel ?? 0;
    message.testTypes = object.testTypes?.map((e) => e) || [];
    message.llmProvider = object.llmProvider ?? "";
    message.checkDuplicates = object.checkDuplicates ?? false;
    message.maxTestCases = object.maxTestCases ?? 0;
    message.priorityFocus = object.priorityFocus ?? "";
    message.count = object.count ?? 0;
    message.includeEdgeCases = object.includeEdgeCases ?? false;
    message.includeNegativeTests = object.includeNegativeTests ?? false;
    message.detailLevel = object.detailLevel ?? "";
    return message;
  },
};

function createBaseTestDataConfig(): TestDataConfig {
  return { generateTestData: false, placement: 0, samplesPerCase: 0 };
}

export const TestDataConfig: MessageFns<TestDataConfig> = {
  encode(message: TestDataConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.generateTestData !== false) {
      writer.uint32(8).bool(message.generateTestData);
    }
    if (message.placement !== 0) {
      writer.uint32(16).int32(message.placement);
    }
    if (message.samplesPerCase !== 0) {
      writer.uint32(24).int32(message.samplesPerCase);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestDataConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestDataConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.generateTestData = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.placement = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.samplesPerCase = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestDataConfig {
    return {
      generateTestData: isSet(object.generateTestData) ? globalThis.Boolean(object.generateTestData) : false,
      placement: isSet(object.placement) ? testDataPlacementFromJSON(object.placement) : 0,
      samplesPerCase: isSet(object.samplesPerCase) ? globalThis.Number(object.samplesPerCase) : 0,
    };
  },

  toJSON(message: TestDataConfig): unknown {
    const obj: any = {};
    if (message.generateTestData !== false) {
      obj.generateTestData = message.generateTestData;
    }
    if (message.placement !== 0) {
      obj.placement = testDataPlacementToJSON(message.placement);
    }
    if (message.samplesPerCase !== 0) {
      obj.samplesPerCase = Math.round(message.samplesPerCase);
    }
    return obj;
  },

  create(base?: DeepPartial<TestDataConfig>): TestDataConfig {
    return TestDataConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TestDataConfig>): TestDataConfig {
    const message = createBaseTestDataConfig();
    message.generateTestData = object.generateTestData ?? false;
    message.placement = object.placement ?? 0;
    message.samplesPerCase = object.samplesPerCase ?? 0;
    return message;
  },
};

function createBaseGenerateTestCasesResponse(): GenerateTestCasesResponse {
  return { requestId: "", success: false, testCases: [], metadata: undefined, errorMessage: "" };
}

export const GenerateTestCasesResponse: MessageFns<GenerateTestCasesResponse> = {
  encode(message: GenerateTestCasesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    for (const v of message.testCases) {
      TestCase.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      GenerationMetadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.errorMessage !== "") {
      writer.uint32(42).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateTestCasesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateTestCasesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.testCases.push(TestCase.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = GenerationMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateTestCasesResponse {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      testCases: globalThis.Array.isArray(object?.testCases)
        ? object.testCases.map((e: any) => TestCase.fromJSON(e))
        : [],
      metadata: isSet(object.metadata) ? GenerationMetadata.fromJSON(object.metadata) : undefined,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
    };
  },

  toJSON(message: GenerateTestCasesResponse): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.testCases?.length) {
      obj.testCases = message.testCases.map((e) => TestCase.toJSON(e));
    }
    if (message.metadata !== undefined) {
      obj.metadata = GenerationMetadata.toJSON(message.metadata);
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateTestCasesResponse>): GenerateTestCasesResponse {
    return GenerateTestCasesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateTestCasesResponse>): GenerateTestCasesResponse {
    const message = createBaseGenerateTestCasesResponse();
    message.requestId = object.requestId ?? "";
    message.success = object.success ?? false;
    message.testCases = object.testCases?.map((e) => TestCase.fromPartial(e)) || [];
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? GenerationMetadata.fromPartial(object.metadata)
      : undefined;
    message.errorMessage = object.errorMessage ?? "";
    return message;
  },
};

function createBaseTestCase(): TestCase {
  return {
    id: "",
    title: "",
    description: "",
    type: 0,
    priority: 0,
    tags: [],
    requirementId: "",
    preconditions: [],
    steps: [],
    gherkin: "",
    testData: undefined,
    expectedResult: "",
    postconditions: [],
    status: 0,
  };
}

export const TestCase: MessageFns<TestCase> = {
  encode(message: TestCase, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.type !== 0) {
      writer.uint32(32).int32(message.type);
    }
    if (message.priority !== 0) {
      writer.uint32(40).int32(message.priority);
    }
    for (const v of message.tags) {
      writer.uint32(50).string(v!);
    }
    if (message.requirementId !== "") {
      writer.uint32(58).string(message.requirementId);
    }
    for (const v of message.preconditions) {
      writer.uint32(66).string(v!);
    }
    for (const v of message.steps) {
      TestStep.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.gherkin !== "") {
      writer.uint32(82).string(message.gherkin);
    }
    if (message.testData !== undefined) {
      TestData.encode(message.testData, writer.uint32(90).fork()).join();
    }
    if (message.expectedResult !== "") {
      writer.uint32(98).string(message.expectedResult);
    }
    for (const v of message.postconditions) {
      writer.uint32(106).string(v!);
    }
    if (message.status !== 0) {
      writer.uint32(112).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestCase {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestCase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.priority = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.requirementId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.preconditions.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.steps.push(TestStep.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.gherkin = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.testData = TestData.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.expectedResult = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.postconditions.push(reader.string());
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestCase {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      type: isSet(object.type) ? testTypeFromJSON(object.type) : 0,
      priority: isSet(object.priority) ? priorityFromJSON(object.priority) : 0,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      requirementId: isSet(object.requirementId) ? globalThis.String(object.requirementId) : "",
      preconditions: globalThis.Array.isArray(object?.preconditions)
        ? object.preconditions.map((e: any) => globalThis.String(e))
        : [],
      steps: globalThis.Array.isArray(object?.steps) ? object.steps.map((e: any) => TestStep.fromJSON(e)) : [],
      gherkin: isSet(object.gherkin) ? globalThis.String(object.gherkin) : "",
      testData: isSet(object.testData) ? TestData.fromJSON(object.testData) : undefined,
      expectedResult: isSet(object.expectedResult) ? globalThis.String(object.expectedResult) : "",
      postconditions: globalThis.Array.isArray(object?.postconditions)
        ? object.postconditions.map((e: any) => globalThis.String(e))
        : [],
      status: isSet(object.status) ? testCaseStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: TestCase): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.type !== 0) {
      obj.type = testTypeToJSON(message.type);
    }
    if (message.priority !== 0) {
      obj.priority = priorityToJSON(message.priority);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.requirementId !== "") {
      obj.requirementId = message.requirementId;
    }
    if (message.preconditions?.length) {
      obj.preconditions = message.preconditions;
    }
    if (message.steps?.length) {
      obj.steps = message.steps.map((e) => TestStep.toJSON(e));
    }
    if (message.gherkin !== "") {
      obj.gherkin = message.gherkin;
    }
    if (message.testData !== undefined) {
      obj.testData = TestData.toJSON(message.testData);
    }
    if (message.expectedResult !== "") {
      obj.expectedResult = message.expectedResult;
    }
    if (message.postconditions?.length) {
      obj.postconditions = message.postconditions;
    }
    if (message.status !== 0) {
      obj.status = testCaseStatusToJSON(message.status);
    }
    return obj;
  },

  create(base?: DeepPartial<TestCase>): TestCase {
    return TestCase.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TestCase>): TestCase {
    const message = createBaseTestCase();
    message.id = object.id ?? "";
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.type = object.type ?? 0;
    message.priority = object.priority ?? 0;
    message.tags = object.tags?.map((e) => e) || [];
    message.requirementId = object.requirementId ?? "";
    message.preconditions = object.preconditions?.map((e) => e) || [];
    message.steps = object.steps?.map((e) => TestStep.fromPartial(e)) || [];
    message.gherkin = object.gherkin ?? "";
    message.testData = (object.testData !== undefined && object.testData !== null)
      ? TestData.fromPartial(object.testData)
      : undefined;
    message.expectedResult = object.expectedResult ?? "";
    message.postconditions = object.postconditions?.map((e) => e) || [];
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseTestStep(): TestStep {
  return { order: 0, action: "", expectedResult: "", testData: "" };
}

export const TestStep: MessageFns<TestStep> = {
  encode(message: TestStep, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.order !== 0) {
      writer.uint32(8).int32(message.order);
    }
    if (message.action !== "") {
      writer.uint32(18).string(message.action);
    }
    if (message.expectedResult !== "") {
      writer.uint32(26).string(message.expectedResult);
    }
    if (message.testData !== "") {
      writer.uint32(34).string(message.testData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestStep {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestStep();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.order = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.action = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.expectedResult = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.testData = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestStep {
    return {
      order: isSet(object.order) ? globalThis.Number(object.order) : 0,
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      expectedResult: isSet(object.expectedResult) ? globalThis.String(object.expectedResult) : "",
      testData: isSet(object.testData) ? globalThis.String(object.testData) : "",
    };
  },

  toJSON(message: TestStep): unknown {
    const obj: any = {};
    if (message.order !== 0) {
      obj.order = Math.round(message.order);
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.expectedResult !== "") {
      obj.expectedResult = message.expectedResult;
    }
    if (message.testData !== "") {
      obj.testData = message.testData;
    }
    return obj;
  },

  create(base?: DeepPartial<TestStep>): TestStep {
    return TestStep.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TestStep>): TestStep {
    const message = createBaseTestStep();
    message.order = object.order ?? 0;
    message.action = object.action ?? "";
    message.expectedResult = object.expectedResult ?? "";
    message.testData = object.testData ?? "";
    return message;
  },
};

function createBaseTestData(): TestData {
  return { items: [] };
}

export const TestData: MessageFns<TestData> = {
  encode(message: TestData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      TestDataItem.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(TestDataItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestData {
    return {
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => TestDataItem.fromJSON(e)) : [],
    };
  },

  toJSON(message: TestData): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => TestDataItem.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TestData>): TestData {
    return TestData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TestData>): TestData {
    const message = createBaseTestData();
    message.items = object.items?.map((e) => TestDataItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTestDataItem(): TestDataItem {
  return { field: "", value: "", description: "" };
}

export const TestDataItem: MessageFns<TestDataItem> = {
  encode(message: TestDataItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestDataItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestDataItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestDataItem {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: TestDataItem): unknown {
    const obj: any = {};
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create(base?: DeepPartial<TestDataItem>): TestDataItem {
    return TestDataItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TestDataItem>): TestDataItem {
    const message = createBaseTestDataItem();
    message.field = object.field ?? "";
    message.value = object.value ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseGenerationMetadata(): GenerationMetadata {
  return {
    llmProvider: "",
    llmModel: "",
    llmTokensUsed: 0,
    generationTimeMs: 0,
    testCasesGenerated: 0,
    duplicatesFound: 0,
    coverage: undefined,
    domainContextUsed: "",
  };
}

export const GenerationMetadata: MessageFns<GenerationMetadata> = {
  encode(message: GenerationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.llmProvider !== "") {
      writer.uint32(10).string(message.llmProvider);
    }
    if (message.llmModel !== "") {
      writer.uint32(18).string(message.llmModel);
    }
    if (message.llmTokensUsed !== 0) {
      writer.uint32(24).int32(message.llmTokensUsed);
    }
    if (message.generationTimeMs !== 0) {
      writer.uint32(37).float(message.generationTimeMs);
    }
    if (message.testCasesGenerated !== 0) {
      writer.uint32(40).int32(message.testCasesGenerated);
    }
    if (message.duplicatesFound !== 0) {
      writer.uint32(48).int32(message.duplicatesFound);
    }
    if (message.coverage !== undefined) {
      CoverageAnalysis.encode(message.coverage, writer.uint32(58).fork()).join();
    }
    if (message.domainContextUsed !== "") {
      writer.uint32(66).string(message.domainContextUsed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.llmProvider = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.llmModel = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.llmTokensUsed = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.generationTimeMs = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.testCasesGenerated = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.duplicatesFound = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.coverage = CoverageAnalysis.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.domainContextUsed = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerationMetadata {
    return {
      llmProvider: isSet(object.llmProvider) ? globalThis.String(object.llmProvider) : "",
      llmModel: isSet(object.llmModel) ? globalThis.String(object.llmModel) : "",
      llmTokensUsed: isSet(object.llmTokensUsed) ? globalThis.Number(object.llmTokensUsed) : 0,
      generationTimeMs: isSet(object.generationTimeMs) ? globalThis.Number(object.generationTimeMs) : 0,
      testCasesGenerated: isSet(object.testCasesGenerated) ? globalThis.Number(object.testCasesGenerated) : 0,
      duplicatesFound: isSet(object.duplicatesFound) ? globalThis.Number(object.duplicatesFound) : 0,
      coverage: isSet(object.coverage) ? CoverageAnalysis.fromJSON(object.coverage) : undefined,
      domainContextUsed: isSet(object.domainContextUsed) ? globalThis.String(object.domainContextUsed) : "",
    };
  },

  toJSON(message: GenerationMetadata): unknown {
    const obj: any = {};
    if (message.llmProvider !== "") {
      obj.llmProvider = message.llmProvider;
    }
    if (message.llmModel !== "") {
      obj.llmModel = message.llmModel;
    }
    if (message.llmTokensUsed !== 0) {
      obj.llmTokensUsed = Math.round(message.llmTokensUsed);
    }
    if (message.generationTimeMs !== 0) {
      obj.generationTimeMs = message.generationTimeMs;
    }
    if (message.testCasesGenerated !== 0) {
      obj.testCasesGenerated = Math.round(message.testCasesGenerated);
    }
    if (message.duplicatesFound !== 0) {
      obj.duplicatesFound = Math.round(message.duplicatesFound);
    }
    if (message.coverage !== undefined) {
      obj.coverage = CoverageAnalysis.toJSON(message.coverage);
    }
    if (message.domainContextUsed !== "") {
      obj.domainContextUsed = message.domainContextUsed;
    }
    return obj;
  },

  create(base?: DeepPartial<GenerationMetadata>): GenerationMetadata {
    return GenerationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerationMetadata>): GenerationMetadata {
    const message = createBaseGenerationMetadata();
    message.llmProvider = object.llmProvider ?? "";
    message.llmModel = object.llmModel ?? "";
    message.llmTokensUsed = object.llmTokensUsed ?? 0;
    message.generationTimeMs = object.generationTimeMs ?? 0;
    message.testCasesGenerated = object.testCasesGenerated ?? 0;
    message.duplicatesFound = object.duplicatesFound ?? 0;
    message.coverage = (object.coverage !== undefined && object.coverage !== null)
      ? CoverageAnalysis.fromPartial(object.coverage)
      : undefined;
    message.domainContextUsed = object.domainContextUsed ?? "";
    return message;
  },
};

function createBaseCoverageAnalysis(): CoverageAnalysis {
  return { functionalCount: 0, negativeCount: 0, boundaryCount: 0, edgeCaseCount: 0, uncoveredAreas: [] };
}

export const CoverageAnalysis: MessageFns<CoverageAnalysis> = {
  encode(message: CoverageAnalysis, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.functionalCount !== 0) {
      writer.uint32(8).int32(message.functionalCount);
    }
    if (message.negativeCount !== 0) {
      writer.uint32(16).int32(message.negativeCount);
    }
    if (message.boundaryCount !== 0) {
      writer.uint32(24).int32(message.boundaryCount);
    }
    if (message.edgeCaseCount !== 0) {
      writer.uint32(32).int32(message.edgeCaseCount);
    }
    for (const v of message.uncoveredAreas) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CoverageAnalysis {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCoverageAnalysis();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.functionalCount = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.negativeCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.boundaryCount = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.edgeCaseCount = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.uncoveredAreas.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CoverageAnalysis {
    return {
      functionalCount: isSet(object.functionalCount) ? globalThis.Number(object.functionalCount) : 0,
      negativeCount: isSet(object.negativeCount) ? globalThis.Number(object.negativeCount) : 0,
      boundaryCount: isSet(object.boundaryCount) ? globalThis.Number(object.boundaryCount) : 0,
      edgeCaseCount: isSet(object.edgeCaseCount) ? globalThis.Number(object.edgeCaseCount) : 0,
      uncoveredAreas: globalThis.Array.isArray(object?.uncoveredAreas)
        ? object.uncoveredAreas.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: CoverageAnalysis): unknown {
    const obj: any = {};
    if (message.functionalCount !== 0) {
      obj.functionalCount = Math.round(message.functionalCount);
    }
    if (message.negativeCount !== 0) {
      obj.negativeCount = Math.round(message.negativeCount);
    }
    if (message.boundaryCount !== 0) {
      obj.boundaryCount = Math.round(message.boundaryCount);
    }
    if (message.edgeCaseCount !== 0) {
      obj.edgeCaseCount = Math.round(message.edgeCaseCount);
    }
    if (message.uncoveredAreas?.length) {
      obj.uncoveredAreas = message.uncoveredAreas;
    }
    return obj;
  },

  create(base?: DeepPartial<CoverageAnalysis>): CoverageAnalysis {
    return CoverageAnalysis.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CoverageAnalysis>): CoverageAnalysis {
    const message = createBaseCoverageAnalysis();
    message.functionalCount = object.functionalCount ?? 0;
    message.negativeCount = object.negativeCount ?? 0;
    message.boundaryCount = object.boundaryCount ?? 0;
    message.edgeCaseCount = object.edgeCaseCount ?? 0;
    message.uncoveredAreas = object.uncoveredAreas?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetTestCaseRequest(): GetTestCaseRequest {
  return { testCaseId: "" };
}

export const GetTestCaseRequest: MessageFns<GetTestCaseRequest> = {
  encode(message: GetTestCaseRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.testCaseId !== "") {
      writer.uint32(10).string(message.testCaseId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTestCaseRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTestCaseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.testCaseId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTestCaseRequest {
    return { testCaseId: isSet(object.testCaseId) ? globalThis.String(object.testCaseId) : "" };
  },

  toJSON(message: GetTestCaseRequest): unknown {
    const obj: any = {};
    if (message.testCaseId !== "") {
      obj.testCaseId = message.testCaseId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTestCaseRequest>): GetTestCaseRequest {
    return GetTestCaseRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTestCaseRequest>): GetTestCaseRequest {
    const message = createBaseGetTestCaseRequest();
    message.testCaseId = object.testCaseId ?? "";
    return message;
  },
};

function createBaseGetTestCaseResponse(): GetTestCaseResponse {
  return { testCase: undefined };
}

export const GetTestCaseResponse: MessageFns<GetTestCaseResponse> = {
  encode(message: GetTestCaseResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.testCase !== undefined) {
      TestCase.encode(message.testCase, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTestCaseResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTestCaseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.testCase = TestCase.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTestCaseResponse {
    return { testCase: isSet(object.testCase) ? TestCase.fromJSON(object.testCase) : undefined };
  },

  toJSON(message: GetTestCaseResponse): unknown {
    const obj: any = {};
    if (message.testCase !== undefined) {
      obj.testCase = TestCase.toJSON(message.testCase);
    }
    return obj;
  },

  create(base?: DeepPartial<GetTestCaseResponse>): GetTestCaseResponse {
    return GetTestCaseResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTestCaseResponse>): GetTestCaseResponse {
    const message = createBaseGetTestCaseResponse();
    message.testCase = (object.testCase !== undefined && object.testCase !== null)
      ? TestCase.fromPartial(object.testCase)
      : undefined;
    return message;
  },
};

function createBaseListTestCasesRequest(): ListTestCasesRequest {
  return { domain: "", entity: "", type: 0, searchQuery: "", limit: 0, offset: 0 };
}

export const ListTestCasesRequest: MessageFns<ListTestCasesRequest> = {
  encode(message: ListTestCasesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.domain !== "") {
      writer.uint32(10).string(message.domain);
    }
    if (message.entity !== "") {
      writer.uint32(18).string(message.entity);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.searchQuery !== "") {
      writer.uint32(34).string(message.searchQuery);
    }
    if (message.limit !== 0) {
      writer.uint32(40).int32(message.limit);
    }
    if (message.offset !== 0) {
      writer.uint32(48).int32(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTestCasesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTestCasesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.domain = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.entity = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.searchQuery = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTestCasesRequest {
    return {
      domain: isSet(object.domain) ? globalThis.String(object.domain) : "",
      entity: isSet(object.entity) ? globalThis.String(object.entity) : "",
      type: isSet(object.type) ? testTypeFromJSON(object.type) : 0,
      searchQuery: isSet(object.searchQuery) ? globalThis.String(object.searchQuery) : "",
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
    };
  },

  toJSON(message: ListTestCasesRequest): unknown {
    const obj: any = {};
    if (message.domain !== "") {
      obj.domain = message.domain;
    }
    if (message.entity !== "") {
      obj.entity = message.entity;
    }
    if (message.type !== 0) {
      obj.type = testTypeToJSON(message.type);
    }
    if (message.searchQuery !== "") {
      obj.searchQuery = message.searchQuery;
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    return obj;
  },

  create(base?: DeepPartial<ListTestCasesRequest>): ListTestCasesRequest {
    return ListTestCasesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTestCasesRequest>): ListTestCasesRequest {
    const message = createBaseListTestCasesRequest();
    message.domain = object.domain ?? "";
    message.entity = object.entity ?? "";
    message.type = object.type ?? 0;
    message.searchQuery = object.searchQuery ?? "";
    message.limit = object.limit ?? 0;
    message.offset = object.offset ?? 0;
    return message;
  },
};

function createBaseListTestCasesResponse(): ListTestCasesResponse {
  return { testCases: [], totalCount: 0 };
}

export const ListTestCasesResponse: MessageFns<ListTestCasesResponse> = {
  encode(message: ListTestCasesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.testCases) {
      TestCaseSummary.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalCount !== 0) {
      writer.uint32(16).int32(message.totalCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTestCasesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTestCasesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.testCases.push(TestCaseSummary.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTestCasesResponse {
    return {
      testCases: globalThis.Array.isArray(object?.testCases)
        ? object.testCases.map((e: any) => TestCaseSummary.fromJSON(e))
        : [],
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
    };
  },

  toJSON(message: ListTestCasesResponse): unknown {
    const obj: any = {};
    if (message.testCases?.length) {
      obj.testCases = message.testCases.map((e) => TestCaseSummary.toJSON(e));
    }
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    return obj;
  },

  create(base?: DeepPartial<ListTestCasesResponse>): ListTestCasesResponse {
    return ListTestCasesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTestCasesResponse>): ListTestCasesResponse {
    const message = createBaseListTestCasesResponse();
    message.testCases = object.testCases?.map((e) => TestCaseSummary.fromPartial(e)) || [];
    message.totalCount = object.totalCount ?? 0;
    return message;
  },
};

function createBaseTestCaseSummary(): TestCaseSummary {
  return { id: "", title: "", type: 0, priority: 0, domain: "", entity: "", createdAt: "" };
}

export const TestCaseSummary: MessageFns<TestCaseSummary> = {
  encode(message: TestCaseSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.priority !== 0) {
      writer.uint32(32).int32(message.priority);
    }
    if (message.domain !== "") {
      writer.uint32(42).string(message.domain);
    }
    if (message.entity !== "") {
      writer.uint32(50).string(message.entity);
    }
    if (message.createdAt !== "") {
      writer.uint32(58).string(message.createdAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestCaseSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestCaseSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.priority = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.domain = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.entity = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestCaseSummary {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      type: isSet(object.type) ? testTypeFromJSON(object.type) : 0,
      priority: isSet(object.priority) ? priorityFromJSON(object.priority) : 0,
      domain: isSet(object.domain) ? globalThis.String(object.domain) : "",
      entity: isSet(object.entity) ? globalThis.String(object.entity) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
    };
  },

  toJSON(message: TestCaseSummary): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.type !== 0) {
      obj.type = testTypeToJSON(message.type);
    }
    if (message.priority !== 0) {
      obj.priority = priorityToJSON(message.priority);
    }
    if (message.domain !== "") {
      obj.domain = message.domain;
    }
    if (message.entity !== "") {
      obj.entity = message.entity;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    return obj;
  },

  create(base?: DeepPartial<TestCaseSummary>): TestCaseSummary {
    return TestCaseSummary.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TestCaseSummary>): TestCaseSummary {
    const message = createBaseTestCaseSummary();
    message.id = object.id ?? "";
    message.title = object.title ?? "";
    message.type = object.type ?? 0;
    message.priority = object.priority ?? 0;
    message.domain = object.domain ?? "";
    message.entity = object.entity ?? "";
    message.createdAt = object.createdAt ?? "";
    return message;
  },
};

function createBaseStoreTestCasesRequest(): StoreTestCasesRequest {
  return { testCases: [], domain: "", entity: "", source: "" };
}

export const StoreTestCasesRequest: MessageFns<StoreTestCasesRequest> = {
  encode(message: StoreTestCasesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.testCases) {
      TestCase.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.domain !== "") {
      writer.uint32(18).string(message.domain);
    }
    if (message.entity !== "") {
      writer.uint32(26).string(message.entity);
    }
    if (message.source !== "") {
      writer.uint32(34).string(message.source);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StoreTestCasesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStoreTestCasesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.testCases.push(TestCase.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.domain = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.entity = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.source = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StoreTestCasesRequest {
    return {
      testCases: globalThis.Array.isArray(object?.testCases)
        ? object.testCases.map((e: any) => TestCase.fromJSON(e))
        : [],
      domain: isSet(object.domain) ? globalThis.String(object.domain) : "",
      entity: isSet(object.entity) ? globalThis.String(object.entity) : "",
      source: isSet(object.source) ? globalThis.String(object.source) : "",
    };
  },

  toJSON(message: StoreTestCasesRequest): unknown {
    const obj: any = {};
    if (message.testCases?.length) {
      obj.testCases = message.testCases.map((e) => TestCase.toJSON(e));
    }
    if (message.domain !== "") {
      obj.domain = message.domain;
    }
    if (message.entity !== "") {
      obj.entity = message.entity;
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    return obj;
  },

  create(base?: DeepPartial<StoreTestCasesRequest>): StoreTestCasesRequest {
    return StoreTestCasesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StoreTestCasesRequest>): StoreTestCasesRequest {
    const message = createBaseStoreTestCasesRequest();
    message.testCases = object.testCases?.map((e) => TestCase.fromPartial(e)) || [];
    message.domain = object.domain ?? "";
    message.entity = object.entity ?? "";
    message.source = object.source ?? "";
    return message;
  },
};

function createBaseStoreTestCasesResponse(): StoreTestCasesResponse {
  return { success: false, storedCount: 0, error: "" };
}

export const StoreTestCasesResponse: MessageFns<StoreTestCasesResponse> = {
  encode(message: StoreTestCasesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.storedCount !== 0) {
      writer.uint32(16).int32(message.storedCount);
    }
    if (message.error !== "") {
      writer.uint32(26).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StoreTestCasesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStoreTestCasesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.storedCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StoreTestCasesResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      storedCount: isSet(object.storedCount) ? globalThis.Number(object.storedCount) : 0,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: StoreTestCasesResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.storedCount !== 0) {
      obj.storedCount = Math.round(message.storedCount);
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create(base?: DeepPartial<StoreTestCasesResponse>): StoreTestCasesResponse {
    return StoreTestCasesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StoreTestCasesResponse>): StoreTestCasesResponse {
    const message = createBaseStoreTestCasesResponse();
    message.success = object.success ?? false;
    message.storedCount = object.storedCount ?? 0;
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseAnalyzeCoverageRequest(): AnalyzeCoverageRequest {
  return { requestId: "", userStory: undefined, apiSpec: undefined, existingTestCaseIds: [] };
}

export const AnalyzeCoverageRequest: MessageFns<AnalyzeCoverageRequest> = {
  encode(message: AnalyzeCoverageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.userStory !== undefined) {
      UserStoryInput.encode(message.userStory, writer.uint32(18).fork()).join();
    }
    if (message.apiSpec !== undefined) {
      ApiSpecInput.encode(message.apiSpec, writer.uint32(26).fork()).join();
    }
    for (const v of message.existingTestCaseIds) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalyzeCoverageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalyzeCoverageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userStory = UserStoryInput.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.apiSpec = ApiSpecInput.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.existingTestCaseIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalyzeCoverageRequest {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      userStory: isSet(object.userStory) ? UserStoryInput.fromJSON(object.userStory) : undefined,
      apiSpec: isSet(object.apiSpec) ? ApiSpecInput.fromJSON(object.apiSpec) : undefined,
      existingTestCaseIds: globalThis.Array.isArray(object?.existingTestCaseIds)
        ? object.existingTestCaseIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: AnalyzeCoverageRequest): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.userStory !== undefined) {
      obj.userStory = UserStoryInput.toJSON(message.userStory);
    }
    if (message.apiSpec !== undefined) {
      obj.apiSpec = ApiSpecInput.toJSON(message.apiSpec);
    }
    if (message.existingTestCaseIds?.length) {
      obj.existingTestCaseIds = message.existingTestCaseIds;
    }
    return obj;
  },

  create(base?: DeepPartial<AnalyzeCoverageRequest>): AnalyzeCoverageRequest {
    return AnalyzeCoverageRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnalyzeCoverageRequest>): AnalyzeCoverageRequest {
    const message = createBaseAnalyzeCoverageRequest();
    message.requestId = object.requestId ?? "";
    message.userStory = (object.userStory !== undefined && object.userStory !== null)
      ? UserStoryInput.fromPartial(object.userStory)
      : undefined;
    message.apiSpec = (object.apiSpec !== undefined && object.apiSpec !== null)
      ? ApiSpecInput.fromPartial(object.apiSpec)
      : undefined;
    message.existingTestCaseIds = object.existingTestCaseIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseAnalyzeCoverageResponse(): AnalyzeCoverageResponse {
  return { requestId: "", report: undefined };
}

export const AnalyzeCoverageResponse: MessageFns<AnalyzeCoverageResponse> = {
  encode(message: AnalyzeCoverageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.report !== undefined) {
      CoverageReport.encode(message.report, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalyzeCoverageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalyzeCoverageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.report = CoverageReport.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalyzeCoverageResponse {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      report: isSet(object.report) ? CoverageReport.fromJSON(object.report) : undefined,
    };
  },

  toJSON(message: AnalyzeCoverageResponse): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.report !== undefined) {
      obj.report = CoverageReport.toJSON(message.report);
    }
    return obj;
  },

  create(base?: DeepPartial<AnalyzeCoverageResponse>): AnalyzeCoverageResponse {
    return AnalyzeCoverageResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnalyzeCoverageResponse>): AnalyzeCoverageResponse {
    const message = createBaseAnalyzeCoverageResponse();
    message.requestId = object.requestId ?? "";
    message.report = (object.report !== undefined && object.report !== null)
      ? CoverageReport.fromPartial(object.report)
      : undefined;
    return message;
  },
};

function createBaseCoverageReport(): CoverageReport {
  return { overallCoverage: 0, gaps: [], recommendations: [] };
}

export const CoverageReport: MessageFns<CoverageReport> = {
  encode(message: CoverageReport, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.overallCoverage !== 0) {
      writer.uint32(13).float(message.overallCoverage);
    }
    for (const v of message.gaps) {
      CoverageGap.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.recommendations) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CoverageReport {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCoverageReport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.overallCoverage = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.gaps.push(CoverageGap.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.recommendations.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CoverageReport {
    return {
      overallCoverage: isSet(object.overallCoverage) ? globalThis.Number(object.overallCoverage) : 0,
      gaps: globalThis.Array.isArray(object?.gaps) ? object.gaps.map((e: any) => CoverageGap.fromJSON(e)) : [],
      recommendations: globalThis.Array.isArray(object?.recommendations)
        ? object.recommendations.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: CoverageReport): unknown {
    const obj: any = {};
    if (message.overallCoverage !== 0) {
      obj.overallCoverage = message.overallCoverage;
    }
    if (message.gaps?.length) {
      obj.gaps = message.gaps.map((e) => CoverageGap.toJSON(e));
    }
    if (message.recommendations?.length) {
      obj.recommendations = message.recommendations;
    }
    return obj;
  },

  create(base?: DeepPartial<CoverageReport>): CoverageReport {
    return CoverageReport.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CoverageReport>): CoverageReport {
    const message = createBaseCoverageReport();
    message.overallCoverage = object.overallCoverage ?? 0;
    message.gaps = object.gaps?.map((e) => CoverageGap.fromPartial(e)) || [];
    message.recommendations = object.recommendations?.map((e) => e) || [];
    return message;
  },
};

function createBaseCoverageGap(): CoverageGap {
  return { area: "", type: "", severity: "", suggestion: "" };
}

export const CoverageGap: MessageFns<CoverageGap> = {
  encode(message: CoverageGap, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.area !== "") {
      writer.uint32(10).string(message.area);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.severity !== "") {
      writer.uint32(26).string(message.severity);
    }
    if (message.suggestion !== "") {
      writer.uint32(34).string(message.suggestion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CoverageGap {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCoverageGap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.area = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.severity = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.suggestion = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CoverageGap {
    return {
      area: isSet(object.area) ? globalThis.String(object.area) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      severity: isSet(object.severity) ? globalThis.String(object.severity) : "",
      suggestion: isSet(object.suggestion) ? globalThis.String(object.suggestion) : "",
    };
  },

  toJSON(message: CoverageGap): unknown {
    const obj: any = {};
    if (message.area !== "") {
      obj.area = message.area;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.severity !== "") {
      obj.severity = message.severity;
    }
    if (message.suggestion !== "") {
      obj.suggestion = message.suggestion;
    }
    return obj;
  },

  create(base?: DeepPartial<CoverageGap>): CoverageGap {
    return CoverageGap.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CoverageGap>): CoverageGap {
    const message = createBaseCoverageGap();
    message.area = object.area ?? "";
    message.type = object.type ?? "";
    message.severity = object.severity ?? "";
    message.suggestion = object.suggestion ?? "";
    return message;
  },
};

function createBaseHealthCheckRequest(): HealthCheckRequest {
  return {};
}

export const HealthCheckRequest: MessageFns<HealthCheckRequest> = {
  encode(_: HealthCheckRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): HealthCheckRequest {
    return {};
  },

  toJSON(_: HealthCheckRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<HealthCheckRequest>): HealthCheckRequest {
    return HealthCheckRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<HealthCheckRequest>): HealthCheckRequest {
    const message = createBaseHealthCheckRequest();
    return message;
  },
};

function createBaseHealthCheckResponse(): HealthCheckResponse {
  return { status: 0, version: "", components: {} };
}

export const HealthCheckResponse: MessageFns<HealthCheckResponse> = {
  encode(message: HealthCheckResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    Object.entries(message.components).forEach(([key, value]) => {
      HealthCheckResponse_ComponentsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = HealthCheckResponse_ComponentsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.components[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheckResponse {
    return {
      status: isSet(object.status) ? healthCheckStatusFromJSON(object.status) : 0,
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      components: isObject(object.components)
        ? Object.entries(object.components).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: HealthCheckResponse): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = healthCheckStatusToJSON(message.status);
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.components) {
      const entries = Object.entries(message.components);
      if (entries.length > 0) {
        obj.components = {};
        entries.forEach(([k, v]) => {
          obj.components[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<HealthCheckResponse>): HealthCheckResponse {
    return HealthCheckResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HealthCheckResponse>): HealthCheckResponse {
    const message = createBaseHealthCheckResponse();
    message.status = object.status ?? 0;
    message.version = object.version ?? "";
    message.components = Object.entries(object.components ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseHealthCheckResponse_ComponentsEntry(): HealthCheckResponse_ComponentsEntry {
  return { key: "", value: "" };
}

export const HealthCheckResponse_ComponentsEntry: MessageFns<HealthCheckResponse_ComponentsEntry> = {
  encode(message: HealthCheckResponse_ComponentsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckResponse_ComponentsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckResponse_ComponentsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheckResponse_ComponentsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: HealthCheckResponse_ComponentsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<HealthCheckResponse_ComponentsEntry>): HealthCheckResponse_ComponentsEntry {
    return HealthCheckResponse_ComponentsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HealthCheckResponse_ComponentsEntry>): HealthCheckResponse_ComponentsEntry {
    const message = createBaseHealthCheckResponse_ComponentsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

export type TestCasesServiceDefinition = typeof TestCasesServiceDefinition;
export const TestCasesServiceDefinition = {
  name: "TestCasesService",
  fullName: "testcases.v1.TestCasesService",
  methods: {
    /** Generate test cases from requirements */
    generateTestCases: {
      name: "GenerateTestCases",
      requestType: GenerateTestCasesRequest,
      requestStream: false,
      responseType: GenerateTestCasesResponse,
      responseStream: false,
      options: {},
    },
    /** Get a specific test case by ID */
    getTestCase: {
      name: "GetTestCase",
      requestType: GetTestCaseRequest,
      requestStream: false,
      responseType: GetTestCaseResponse,
      responseStream: false,
      options: {},
    },
    /** List historical test cases */
    listTestCases: {
      name: "ListTestCases",
      requestType: ListTestCasesRequest,
      requestStream: false,
      responseType: ListTestCasesResponse,
      responseStream: false,
      options: {},
    },
    /** Store test cases (for learning) */
    storeTestCases: {
      name: "StoreTestCases",
      requestType: StoreTestCasesRequest,
      requestStream: false,
      responseType: StoreTestCasesResponse,
      responseStream: false,
      options: {},
    },
    /** Get coverage analysis for requirements */
    analyzeCoverage: {
      name: "AnalyzeCoverage",
      requestType: AnalyzeCoverageRequest,
      requestStream: false,
      responseType: AnalyzeCoverageResponse,
      responseStream: false,
      options: {},
    },
    /** Health check */
    healthCheck: {
      name: "HealthCheck",
      requestType: HealthCheckRequest,
      requestStream: false,
      responseType: HealthCheckResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface TestCasesServiceImplementation<CallContextExt = {}> {
  /** Generate test cases from requirements */
  generateTestCases(
    request: GenerateTestCasesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GenerateTestCasesResponse>>;
  /** Get a specific test case by ID */
  getTestCase(
    request: GetTestCaseRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetTestCaseResponse>>;
  /** List historical test cases */
  listTestCases(
    request: ListTestCasesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListTestCasesResponse>>;
  /** Store test cases (for learning) */
  storeTestCases(
    request: StoreTestCasesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<StoreTestCasesResponse>>;
  /** Get coverage analysis for requirements */
  analyzeCoverage(
    request: AnalyzeCoverageRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AnalyzeCoverageResponse>>;
  /** Health check */
  healthCheck(
    request: HealthCheckRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<HealthCheckResponse>>;
}

export interface TestCasesServiceClient<CallOptionsExt = {}> {
  /** Generate test cases from requirements */
  generateTestCases(
    request: DeepPartial<GenerateTestCasesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GenerateTestCasesResponse>;
  /** Get a specific test case by ID */
  getTestCase(
    request: DeepPartial<GetTestCaseRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetTestCaseResponse>;
  /** List historical test cases */
  listTestCases(
    request: DeepPartial<ListTestCasesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListTestCasesResponse>;
  /** Store test cases (for learning) */
  storeTestCases(
    request: DeepPartial<StoreTestCasesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<StoreTestCasesResponse>;
  /** Get coverage analysis for requirements */
  analyzeCoverage(
    request: DeepPartial<AnalyzeCoverageRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AnalyzeCoverageResponse>;
  /** Health check */
  healthCheck(
    request: DeepPartial<HealthCheckRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<HealthCheckResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}

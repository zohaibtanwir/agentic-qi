// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.10.0
//   protoc               v4.25.3
// source: ecommerce_domain.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { CallContext, CallOptions } from "nice-grpc-common";

export const protobufPackage = "ecommerce.domain.v1";

/** Generation method enum */
export enum GenerationMethod {
  GENERATION_METHOD_UNSPECIFIED = 0,
  GENERATION_METHOD_TRADITIONAL = 1,
  GENERATION_METHOD_LLM = 2,
  GENERATION_METHOD_RAG = 3,
  GENERATION_METHOD_HYBRID = 4,
  UNRECOGNIZED = -1,
}

export function generationMethodFromJSON(object: any): GenerationMethod {
  switch (object) {
    case 0:
    case "GENERATION_METHOD_UNSPECIFIED":
      return GenerationMethod.GENERATION_METHOD_UNSPECIFIED;
    case 1:
    case "GENERATION_METHOD_TRADITIONAL":
      return GenerationMethod.GENERATION_METHOD_TRADITIONAL;
    case 2:
    case "GENERATION_METHOD_LLM":
      return GenerationMethod.GENERATION_METHOD_LLM;
    case 3:
    case "GENERATION_METHOD_RAG":
      return GenerationMethod.GENERATION_METHOD_RAG;
    case 4:
    case "GENERATION_METHOD_HYBRID":
      return GenerationMethod.GENERATION_METHOD_HYBRID;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GenerationMethod.UNRECOGNIZED;
  }
}

export function generationMethodToJSON(object: GenerationMethod): string {
  switch (object) {
    case GenerationMethod.GENERATION_METHOD_UNSPECIFIED:
      return "GENERATION_METHOD_UNSPECIFIED";
    case GenerationMethod.GENERATION_METHOD_TRADITIONAL:
      return "GENERATION_METHOD_TRADITIONAL";
    case GenerationMethod.GENERATION_METHOD_LLM:
      return "GENERATION_METHOD_LLM";
    case GenerationMethod.GENERATION_METHOD_RAG:
      return "GENERATION_METHOD_RAG";
    case GenerationMethod.GENERATION_METHOD_HYBRID:
      return "GENERATION_METHOD_HYBRID";
    case GenerationMethod.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface DomainContextRequest {
  requestId: string;
  entity: string;
  workflow: string;
  scenario: string;
  aspects: string[];
}

export interface DomainContextResponse {
  requestId: string;
  context: string;
  rules: BusinessRule[];
  relationships: EntityRelationship[];
  edgeCases: string[];
  metadata: { [key: string]: string };
}

export interface DomainContextResponse_MetadataEntry {
  key: string;
  value: string;
}

export interface BusinessRule {
  id: string;
  name: string;
  description: string;
  entity: string;
  condition: string;
  constraint: string;
  severity: string;
}

export interface EntityRelationship {
  sourceEntity: string;
  targetEntity: string;
  relationshipType: string;
  description: string;
  required: boolean;
}

export interface KnowledgeRequest {
  requestId: string;
  query: string;
  categories: string[];
  maxResults: number;
}

export interface KnowledgeResponse {
  requestId: string;
  items: KnowledgeItem[];
  summary: string;
}

export interface KnowledgeItem {
  id: string;
  category: string;
  title: string;
  content: string;
  relevanceScore: number;
  metadata: { [key: string]: string };
}

export interface KnowledgeItem_MetadataEntry {
  key: string;
  value: string;
}

export interface EntityRequest {
  entityName: string;
  includeRelationships: boolean;
  includeRules: boolean;
  includeEdgeCases: boolean;
}

export interface EntityResponse {
  entity: Entity | undefined;
}

export interface Entity {
  name: string;
  description: string;
  fields: EntityField[];
  rules: BusinessRule[];
  relationships: EntityRelationship[];
  edgeCases: string[];
  testScenarios: string[];
}

export interface EntityField {
  name: string;
  type: string;
  description: string;
  required: boolean;
  validations: string[];
  example: string;
}

export interface ListEntitiesRequest {
  category: string;
}

export interface ListEntitiesResponse {
  entities: EntitySummary[];
}

export interface EntitySummary {
  name: string;
  description: string;
  category: string;
  fieldCount: number;
}

export interface WorkflowRequest {
  workflowName: string;
  includeSteps: boolean;
  includeEdgeCases: boolean;
}

export interface WorkflowResponse {
  workflow: Workflow | undefined;
}

export interface Workflow {
  name: string;
  description: string;
  steps: WorkflowStep[];
  involvedEntities: string[];
  rules: BusinessRule[];
  edgeCases: string[];
  testScenarios: string[];
}

export interface WorkflowStep {
  order: number;
  name: string;
  description: string;
  entity: string;
  action: string;
  validations: string[];
  possibleOutcomes: string[];
}

export interface ListWorkflowsRequest {
}

export interface ListWorkflowsResponse {
  workflows: WorkflowSummary[];
}

export interface WorkflowSummary {
  name: string;
  description: string;
  stepCount: number;
  involvedEntities: string[];
}

export interface EdgeCasesRequest {
  entity: string;
  workflow: string;
  category: string;
}

export interface EdgeCasesResponse {
  edgeCases: EdgeCase[];
}

export interface EdgeCase {
  id: string;
  name: string;
  description: string;
  category: string;
  entity: string;
  workflow: string;
  testApproach: string;
  exampleData: { [key: string]: string };
  expectedBehavior: string;
  severity: string;
}

export interface EdgeCase_ExampleDataEntry {
  key: string;
  value: string;
}

export interface GenerateTestDataRequest {
  requestId: string;
  entity: string;
  count: number;
  workflowContext: string;
  scenarios: string[];
  customContext: string;
  includeEdgeCases: boolean;
  outputFormat: string;
  scenarioCounts: { [key: string]: number };
  generationMethod: GenerationMethod;
  productionLike: boolean;
  useCache: boolean;
}

export interface GenerateTestDataRequest_ScenarioCountsEntry {
  key: string;
  value: number;
}

export interface GenerateTestDataResponse {
  requestId: string;
  success: boolean;
  data: string;
  recordCount: number;
  metadata: GenerationMetadata | undefined;
  error: string;
}

export interface GenerationMetadata {
  generationPath: string;
  llmTokensUsed: number;
  generationTimeMs: number;
  coherenceScore: number;
  domainContextUsed: string;
  scenarioCounts: { [key: string]: number };
}

export interface GenerationMetadata_ScenarioCountsEntry {
  key: string;
  value: number;
}

export interface HealthCheckRequest {
}

export interface HealthCheckResponse {
  status: string;
  components: { [key: string]: string };
}

export interface HealthCheckResponse_ComponentsEntry {
  key: string;
  value: string;
}

function createBaseDomainContextRequest(): DomainContextRequest {
  return { requestId: "", entity: "", workflow: "", scenario: "", aspects: [] };
}

export const DomainContextRequest: MessageFns<DomainContextRequest> = {
  encode(message: DomainContextRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.entity !== "") {
      writer.uint32(18).string(message.entity);
    }
    if (message.workflow !== "") {
      writer.uint32(26).string(message.workflow);
    }
    if (message.scenario !== "") {
      writer.uint32(34).string(message.scenario);
    }
    for (const v of message.aspects) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DomainContextRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDomainContextRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.entity = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.workflow = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.scenario = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.aspects.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DomainContextRequest {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      entity: isSet(object.entity) ? globalThis.String(object.entity) : "",
      workflow: isSet(object.workflow) ? globalThis.String(object.workflow) : "",
      scenario: isSet(object.scenario) ? globalThis.String(object.scenario) : "",
      aspects: globalThis.Array.isArray(object?.aspects) ? object.aspects.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: DomainContextRequest): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.entity !== "") {
      obj.entity = message.entity;
    }
    if (message.workflow !== "") {
      obj.workflow = message.workflow;
    }
    if (message.scenario !== "") {
      obj.scenario = message.scenario;
    }
    if (message.aspects?.length) {
      obj.aspects = message.aspects;
    }
    return obj;
  },

  create(base?: DeepPartial<DomainContextRequest>): DomainContextRequest {
    return DomainContextRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DomainContextRequest>): DomainContextRequest {
    const message = createBaseDomainContextRequest();
    message.requestId = object.requestId ?? "";
    message.entity = object.entity ?? "";
    message.workflow = object.workflow ?? "";
    message.scenario = object.scenario ?? "";
    message.aspects = object.aspects?.map((e) => e) || [];
    return message;
  },
};

function createBaseDomainContextResponse(): DomainContextResponse {
  return { requestId: "", context: "", rules: [], relationships: [], edgeCases: [], metadata: {} };
}

export const DomainContextResponse: MessageFns<DomainContextResponse> = {
  encode(message: DomainContextResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.context !== "") {
      writer.uint32(18).string(message.context);
    }
    for (const v of message.rules) {
      BusinessRule.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.relationships) {
      EntityRelationship.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.edgeCases) {
      writer.uint32(42).string(v!);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      DomainContextResponse_MetadataEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DomainContextResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDomainContextResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.context = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rules.push(BusinessRule.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.relationships.push(EntityRelationship.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.edgeCases.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = DomainContextResponse_MetadataEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.metadata[entry6.key] = entry6.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DomainContextResponse {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      context: isSet(object.context) ? globalThis.String(object.context) : "",
      rules: globalThis.Array.isArray(object?.rules) ? object.rules.map((e: any) => BusinessRule.fromJSON(e)) : [],
      relationships: globalThis.Array.isArray(object?.relationships)
        ? object.relationships.map((e: any) => EntityRelationship.fromJSON(e))
        : [],
      edgeCases: globalThis.Array.isArray(object?.edgeCases)
        ? object.edgeCases.map((e: any) => globalThis.String(e))
        : [],
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: DomainContextResponse): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.context !== "") {
      obj.context = message.context;
    }
    if (message.rules?.length) {
      obj.rules = message.rules.map((e) => BusinessRule.toJSON(e));
    }
    if (message.relationships?.length) {
      obj.relationships = message.relationships.map((e) => EntityRelationship.toJSON(e));
    }
    if (message.edgeCases?.length) {
      obj.edgeCases = message.edgeCases;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<DomainContextResponse>): DomainContextResponse {
    return DomainContextResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DomainContextResponse>): DomainContextResponse {
    const message = createBaseDomainContextResponse();
    message.requestId = object.requestId ?? "";
    message.context = object.context ?? "";
    message.rules = object.rules?.map((e) => BusinessRule.fromPartial(e)) || [];
    message.relationships = object.relationships?.map((e) => EntityRelationship.fromPartial(e)) || [];
    message.edgeCases = object.edgeCases?.map((e) => e) || [];
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseDomainContextResponse_MetadataEntry(): DomainContextResponse_MetadataEntry {
  return { key: "", value: "" };
}

export const DomainContextResponse_MetadataEntry: MessageFns<DomainContextResponse_MetadataEntry> = {
  encode(message: DomainContextResponse_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DomainContextResponse_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDomainContextResponse_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DomainContextResponse_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: DomainContextResponse_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<DomainContextResponse_MetadataEntry>): DomainContextResponse_MetadataEntry {
    return DomainContextResponse_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DomainContextResponse_MetadataEntry>): DomainContextResponse_MetadataEntry {
    const message = createBaseDomainContextResponse_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseBusinessRule(): BusinessRule {
  return { id: "", name: "", description: "", entity: "", condition: "", constraint: "", severity: "" };
}

export const BusinessRule: MessageFns<BusinessRule> = {
  encode(message: BusinessRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.entity !== "") {
      writer.uint32(34).string(message.entity);
    }
    if (message.condition !== "") {
      writer.uint32(42).string(message.condition);
    }
    if (message.constraint !== "") {
      writer.uint32(50).string(message.constraint);
    }
    if (message.severity !== "") {
      writer.uint32(58).string(message.severity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.entity = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.condition = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.constraint = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.severity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BusinessRule {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      entity: isSet(object.entity) ? globalThis.String(object.entity) : "",
      condition: isSet(object.condition) ? globalThis.String(object.condition) : "",
      constraint: isSet(object.constraint) ? globalThis.String(object.constraint) : "",
      severity: isSet(object.severity) ? globalThis.String(object.severity) : "",
    };
  },

  toJSON(message: BusinessRule): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.entity !== "") {
      obj.entity = message.entity;
    }
    if (message.condition !== "") {
      obj.condition = message.condition;
    }
    if (message.constraint !== "") {
      obj.constraint = message.constraint;
    }
    if (message.severity !== "") {
      obj.severity = message.severity;
    }
    return obj;
  },

  create(base?: DeepPartial<BusinessRule>): BusinessRule {
    return BusinessRule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BusinessRule>): BusinessRule {
    const message = createBaseBusinessRule();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.entity = object.entity ?? "";
    message.condition = object.condition ?? "";
    message.constraint = object.constraint ?? "";
    message.severity = object.severity ?? "";
    return message;
  },
};

function createBaseEntityRelationship(): EntityRelationship {
  return { sourceEntity: "", targetEntity: "", relationshipType: "", description: "", required: false };
}

export const EntityRelationship: MessageFns<EntityRelationship> = {
  encode(message: EntityRelationship, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourceEntity !== "") {
      writer.uint32(10).string(message.sourceEntity);
    }
    if (message.targetEntity !== "") {
      writer.uint32(18).string(message.targetEntity);
    }
    if (message.relationshipType !== "") {
      writer.uint32(26).string(message.relationshipType);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.required !== false) {
      writer.uint32(40).bool(message.required);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EntityRelationship {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntityRelationship();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sourceEntity = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.relationshipType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.required = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EntityRelationship {
    return {
      sourceEntity: isSet(object.sourceEntity) ? globalThis.String(object.sourceEntity) : "",
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
      relationshipType: isSet(object.relationshipType) ? globalThis.String(object.relationshipType) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      required: isSet(object.required) ? globalThis.Boolean(object.required) : false,
    };
  },

  toJSON(message: EntityRelationship): unknown {
    const obj: any = {};
    if (message.sourceEntity !== "") {
      obj.sourceEntity = message.sourceEntity;
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    if (message.relationshipType !== "") {
      obj.relationshipType = message.relationshipType;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.required !== false) {
      obj.required = message.required;
    }
    return obj;
  },

  create(base?: DeepPartial<EntityRelationship>): EntityRelationship {
    return EntityRelationship.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EntityRelationship>): EntityRelationship {
    const message = createBaseEntityRelationship();
    message.sourceEntity = object.sourceEntity ?? "";
    message.targetEntity = object.targetEntity ?? "";
    message.relationshipType = object.relationshipType ?? "";
    message.description = object.description ?? "";
    message.required = object.required ?? false;
    return message;
  },
};

function createBaseKnowledgeRequest(): KnowledgeRequest {
  return { requestId: "", query: "", categories: [], maxResults: 0 };
}

export const KnowledgeRequest: MessageFns<KnowledgeRequest> = {
  encode(message: KnowledgeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.query !== "") {
      writer.uint32(18).string(message.query);
    }
    for (const v of message.categories) {
      writer.uint32(26).string(v!);
    }
    if (message.maxResults !== 0) {
      writer.uint32(32).int32(message.maxResults);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KnowledgeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKnowledgeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.query = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.categories.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.maxResults = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KnowledgeRequest {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      categories: globalThis.Array.isArray(object?.categories)
        ? object.categories.map((e: any) => globalThis.String(e))
        : [],
      maxResults: isSet(object.maxResults) ? globalThis.Number(object.maxResults) : 0,
    };
  },

  toJSON(message: KnowledgeRequest): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.categories?.length) {
      obj.categories = message.categories;
    }
    if (message.maxResults !== 0) {
      obj.maxResults = Math.round(message.maxResults);
    }
    return obj;
  },

  create(base?: DeepPartial<KnowledgeRequest>): KnowledgeRequest {
    return KnowledgeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KnowledgeRequest>): KnowledgeRequest {
    const message = createBaseKnowledgeRequest();
    message.requestId = object.requestId ?? "";
    message.query = object.query ?? "";
    message.categories = object.categories?.map((e) => e) || [];
    message.maxResults = object.maxResults ?? 0;
    return message;
  },
};

function createBaseKnowledgeResponse(): KnowledgeResponse {
  return { requestId: "", items: [], summary: "" };
}

export const KnowledgeResponse: MessageFns<KnowledgeResponse> = {
  encode(message: KnowledgeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    for (const v of message.items) {
      KnowledgeItem.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.summary !== "") {
      writer.uint32(26).string(message.summary);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KnowledgeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKnowledgeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.items.push(KnowledgeItem.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.summary = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KnowledgeResponse {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => KnowledgeItem.fromJSON(e)) : [],
      summary: isSet(object.summary) ? globalThis.String(object.summary) : "",
    };
  },

  toJSON(message: KnowledgeResponse): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => KnowledgeItem.toJSON(e));
    }
    if (message.summary !== "") {
      obj.summary = message.summary;
    }
    return obj;
  },

  create(base?: DeepPartial<KnowledgeResponse>): KnowledgeResponse {
    return KnowledgeResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KnowledgeResponse>): KnowledgeResponse {
    const message = createBaseKnowledgeResponse();
    message.requestId = object.requestId ?? "";
    message.items = object.items?.map((e) => KnowledgeItem.fromPartial(e)) || [];
    message.summary = object.summary ?? "";
    return message;
  },
};

function createBaseKnowledgeItem(): KnowledgeItem {
  return { id: "", category: "", title: "", content: "", relevanceScore: 0, metadata: {} };
}

export const KnowledgeItem: MessageFns<KnowledgeItem> = {
  encode(message: KnowledgeItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.category !== "") {
      writer.uint32(18).string(message.category);
    }
    if (message.title !== "") {
      writer.uint32(26).string(message.title);
    }
    if (message.content !== "") {
      writer.uint32(34).string(message.content);
    }
    if (message.relevanceScore !== 0) {
      writer.uint32(45).float(message.relevanceScore);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      KnowledgeItem_MetadataEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KnowledgeItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKnowledgeItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.category = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.relevanceScore = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = KnowledgeItem_MetadataEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.metadata[entry6.key] = entry6.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KnowledgeItem {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      category: isSet(object.category) ? globalThis.String(object.category) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      relevanceScore: isSet(object.relevanceScore) ? globalThis.Number(object.relevanceScore) : 0,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: KnowledgeItem): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.category !== "") {
      obj.category = message.category;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.relevanceScore !== 0) {
      obj.relevanceScore = message.relevanceScore;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<KnowledgeItem>): KnowledgeItem {
    return KnowledgeItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KnowledgeItem>): KnowledgeItem {
    const message = createBaseKnowledgeItem();
    message.id = object.id ?? "";
    message.category = object.category ?? "";
    message.title = object.title ?? "";
    message.content = object.content ?? "";
    message.relevanceScore = object.relevanceScore ?? 0;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseKnowledgeItem_MetadataEntry(): KnowledgeItem_MetadataEntry {
  return { key: "", value: "" };
}

export const KnowledgeItem_MetadataEntry: MessageFns<KnowledgeItem_MetadataEntry> = {
  encode(message: KnowledgeItem_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KnowledgeItem_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKnowledgeItem_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KnowledgeItem_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: KnowledgeItem_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<KnowledgeItem_MetadataEntry>): KnowledgeItem_MetadataEntry {
    return KnowledgeItem_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KnowledgeItem_MetadataEntry>): KnowledgeItem_MetadataEntry {
    const message = createBaseKnowledgeItem_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseEntityRequest(): EntityRequest {
  return { entityName: "", includeRelationships: false, includeRules: false, includeEdgeCases: false };
}

export const EntityRequest: MessageFns<EntityRequest> = {
  encode(message: EntityRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.entityName !== "") {
      writer.uint32(10).string(message.entityName);
    }
    if (message.includeRelationships !== false) {
      writer.uint32(16).bool(message.includeRelationships);
    }
    if (message.includeRules !== false) {
      writer.uint32(24).bool(message.includeRules);
    }
    if (message.includeEdgeCases !== false) {
      writer.uint32(32).bool(message.includeEdgeCases);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EntityRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntityRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entityName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.includeRelationships = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.includeRules = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.includeEdgeCases = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EntityRequest {
    return {
      entityName: isSet(object.entityName) ? globalThis.String(object.entityName) : "",
      includeRelationships: isSet(object.includeRelationships)
        ? globalThis.Boolean(object.includeRelationships)
        : false,
      includeRules: isSet(object.includeRules) ? globalThis.Boolean(object.includeRules) : false,
      includeEdgeCases: isSet(object.includeEdgeCases) ? globalThis.Boolean(object.includeEdgeCases) : false,
    };
  },

  toJSON(message: EntityRequest): unknown {
    const obj: any = {};
    if (message.entityName !== "") {
      obj.entityName = message.entityName;
    }
    if (message.includeRelationships !== false) {
      obj.includeRelationships = message.includeRelationships;
    }
    if (message.includeRules !== false) {
      obj.includeRules = message.includeRules;
    }
    if (message.includeEdgeCases !== false) {
      obj.includeEdgeCases = message.includeEdgeCases;
    }
    return obj;
  },

  create(base?: DeepPartial<EntityRequest>): EntityRequest {
    return EntityRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EntityRequest>): EntityRequest {
    const message = createBaseEntityRequest();
    message.entityName = object.entityName ?? "";
    message.includeRelationships = object.includeRelationships ?? false;
    message.includeRules = object.includeRules ?? false;
    message.includeEdgeCases = object.includeEdgeCases ?? false;
    return message;
  },
};

function createBaseEntityResponse(): EntityResponse {
  return { entity: undefined };
}

export const EntityResponse: MessageFns<EntityResponse> = {
  encode(message: EntityResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.entity !== undefined) {
      Entity.encode(message.entity, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EntityResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntityResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entity = Entity.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EntityResponse {
    return { entity: isSet(object.entity) ? Entity.fromJSON(object.entity) : undefined };
  },

  toJSON(message: EntityResponse): unknown {
    const obj: any = {};
    if (message.entity !== undefined) {
      obj.entity = Entity.toJSON(message.entity);
    }
    return obj;
  },

  create(base?: DeepPartial<EntityResponse>): EntityResponse {
    return EntityResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EntityResponse>): EntityResponse {
    const message = createBaseEntityResponse();
    message.entity = (object.entity !== undefined && object.entity !== null)
      ? Entity.fromPartial(object.entity)
      : undefined;
    return message;
  },
};

function createBaseEntity(): Entity {
  return { name: "", description: "", fields: [], rules: [], relationships: [], edgeCases: [], testScenarios: [] };
}

export const Entity: MessageFns<Entity> = {
  encode(message: Entity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    for (const v of message.fields) {
      EntityField.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.rules) {
      BusinessRule.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.relationships) {
      EntityRelationship.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.edgeCases) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.testScenarios) {
      writer.uint32(58).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Entity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fields.push(EntityField.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.rules.push(BusinessRule.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.relationships.push(EntityRelationship.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.edgeCases.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.testScenarios.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Entity {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      fields: globalThis.Array.isArray(object?.fields) ? object.fields.map((e: any) => EntityField.fromJSON(e)) : [],
      rules: globalThis.Array.isArray(object?.rules) ? object.rules.map((e: any) => BusinessRule.fromJSON(e)) : [],
      relationships: globalThis.Array.isArray(object?.relationships)
        ? object.relationships.map((e: any) => EntityRelationship.fromJSON(e))
        : [],
      edgeCases: globalThis.Array.isArray(object?.edgeCases)
        ? object.edgeCases.map((e: any) => globalThis.String(e))
        : [],
      testScenarios: globalThis.Array.isArray(object?.testScenarios)
        ? object.testScenarios.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Entity): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.fields?.length) {
      obj.fields = message.fields.map((e) => EntityField.toJSON(e));
    }
    if (message.rules?.length) {
      obj.rules = message.rules.map((e) => BusinessRule.toJSON(e));
    }
    if (message.relationships?.length) {
      obj.relationships = message.relationships.map((e) => EntityRelationship.toJSON(e));
    }
    if (message.edgeCases?.length) {
      obj.edgeCases = message.edgeCases;
    }
    if (message.testScenarios?.length) {
      obj.testScenarios = message.testScenarios;
    }
    return obj;
  },

  create(base?: DeepPartial<Entity>): Entity {
    return Entity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Entity>): Entity {
    const message = createBaseEntity();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.fields = object.fields?.map((e) => EntityField.fromPartial(e)) || [];
    message.rules = object.rules?.map((e) => BusinessRule.fromPartial(e)) || [];
    message.relationships = object.relationships?.map((e) => EntityRelationship.fromPartial(e)) || [];
    message.edgeCases = object.edgeCases?.map((e) => e) || [];
    message.testScenarios = object.testScenarios?.map((e) => e) || [];
    return message;
  },
};

function createBaseEntityField(): EntityField {
  return { name: "", type: "", description: "", required: false, validations: [], example: "" };
}

export const EntityField: MessageFns<EntityField> = {
  encode(message: EntityField, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.required !== false) {
      writer.uint32(32).bool(message.required);
    }
    for (const v of message.validations) {
      writer.uint32(42).string(v!);
    }
    if (message.example !== "") {
      writer.uint32(50).string(message.example);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EntityField {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntityField();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.required = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.validations.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.example = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EntityField {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      required: isSet(object.required) ? globalThis.Boolean(object.required) : false,
      validations: globalThis.Array.isArray(object?.validations)
        ? object.validations.map((e: any) => globalThis.String(e))
        : [],
      example: isSet(object.example) ? globalThis.String(object.example) : "",
    };
  },

  toJSON(message: EntityField): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.required !== false) {
      obj.required = message.required;
    }
    if (message.validations?.length) {
      obj.validations = message.validations;
    }
    if (message.example !== "") {
      obj.example = message.example;
    }
    return obj;
  },

  create(base?: DeepPartial<EntityField>): EntityField {
    return EntityField.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EntityField>): EntityField {
    const message = createBaseEntityField();
    message.name = object.name ?? "";
    message.type = object.type ?? "";
    message.description = object.description ?? "";
    message.required = object.required ?? false;
    message.validations = object.validations?.map((e) => e) || [];
    message.example = object.example ?? "";
    return message;
  },
};

function createBaseListEntitiesRequest(): ListEntitiesRequest {
  return { category: "" };
}

export const ListEntitiesRequest: MessageFns<ListEntitiesRequest> = {
  encode(message: ListEntitiesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.category !== "") {
      writer.uint32(10).string(message.category);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListEntitiesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEntitiesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.category = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListEntitiesRequest {
    return { category: isSet(object.category) ? globalThis.String(object.category) : "" };
  },

  toJSON(message: ListEntitiesRequest): unknown {
    const obj: any = {};
    if (message.category !== "") {
      obj.category = message.category;
    }
    return obj;
  },

  create(base?: DeepPartial<ListEntitiesRequest>): ListEntitiesRequest {
    return ListEntitiesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListEntitiesRequest>): ListEntitiesRequest {
    const message = createBaseListEntitiesRequest();
    message.category = object.category ?? "";
    return message;
  },
};

function createBaseListEntitiesResponse(): ListEntitiesResponse {
  return { entities: [] };
}

export const ListEntitiesResponse: MessageFns<ListEntitiesResponse> = {
  encode(message: ListEntitiesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entities) {
      EntitySummary.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListEntitiesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEntitiesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entities.push(EntitySummary.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListEntitiesResponse {
    return {
      entities: globalThis.Array.isArray(object?.entities)
        ? object.entities.map((e: any) => EntitySummary.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListEntitiesResponse): unknown {
    const obj: any = {};
    if (message.entities?.length) {
      obj.entities = message.entities.map((e) => EntitySummary.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListEntitiesResponse>): ListEntitiesResponse {
    return ListEntitiesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListEntitiesResponse>): ListEntitiesResponse {
    const message = createBaseListEntitiesResponse();
    message.entities = object.entities?.map((e) => EntitySummary.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEntitySummary(): EntitySummary {
  return { name: "", description: "", category: "", fieldCount: 0 };
}

export const EntitySummary: MessageFns<EntitySummary> = {
  encode(message: EntitySummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.category !== "") {
      writer.uint32(26).string(message.category);
    }
    if (message.fieldCount !== 0) {
      writer.uint32(32).int32(message.fieldCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EntitySummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntitySummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.category = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.fieldCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EntitySummary {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      category: isSet(object.category) ? globalThis.String(object.category) : "",
      fieldCount: isSet(object.fieldCount) ? globalThis.Number(object.fieldCount) : 0,
    };
  },

  toJSON(message: EntitySummary): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.category !== "") {
      obj.category = message.category;
    }
    if (message.fieldCount !== 0) {
      obj.fieldCount = Math.round(message.fieldCount);
    }
    return obj;
  },

  create(base?: DeepPartial<EntitySummary>): EntitySummary {
    return EntitySummary.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EntitySummary>): EntitySummary {
    const message = createBaseEntitySummary();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.category = object.category ?? "";
    message.fieldCount = object.fieldCount ?? 0;
    return message;
  },
};

function createBaseWorkflowRequest(): WorkflowRequest {
  return { workflowName: "", includeSteps: false, includeEdgeCases: false };
}

export const WorkflowRequest: MessageFns<WorkflowRequest> = {
  encode(message: WorkflowRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workflowName !== "") {
      writer.uint32(10).string(message.workflowName);
    }
    if (message.includeSteps !== false) {
      writer.uint32(16).bool(message.includeSteps);
    }
    if (message.includeEdgeCases !== false) {
      writer.uint32(24).bool(message.includeEdgeCases);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkflowRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workflowName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.includeSteps = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.includeEdgeCases = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkflowRequest {
    return {
      workflowName: isSet(object.workflowName) ? globalThis.String(object.workflowName) : "",
      includeSteps: isSet(object.includeSteps) ? globalThis.Boolean(object.includeSteps) : false,
      includeEdgeCases: isSet(object.includeEdgeCases) ? globalThis.Boolean(object.includeEdgeCases) : false,
    };
  },

  toJSON(message: WorkflowRequest): unknown {
    const obj: any = {};
    if (message.workflowName !== "") {
      obj.workflowName = message.workflowName;
    }
    if (message.includeSteps !== false) {
      obj.includeSteps = message.includeSteps;
    }
    if (message.includeEdgeCases !== false) {
      obj.includeEdgeCases = message.includeEdgeCases;
    }
    return obj;
  },

  create(base?: DeepPartial<WorkflowRequest>): WorkflowRequest {
    return WorkflowRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkflowRequest>): WorkflowRequest {
    const message = createBaseWorkflowRequest();
    message.workflowName = object.workflowName ?? "";
    message.includeSteps = object.includeSteps ?? false;
    message.includeEdgeCases = object.includeEdgeCases ?? false;
    return message;
  },
};

function createBaseWorkflowResponse(): WorkflowResponse {
  return { workflow: undefined };
}

export const WorkflowResponse: MessageFns<WorkflowResponse> = {
  encode(message: WorkflowResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workflow !== undefined) {
      Workflow.encode(message.workflow, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkflowResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workflow = Workflow.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkflowResponse {
    return { workflow: isSet(object.workflow) ? Workflow.fromJSON(object.workflow) : undefined };
  },

  toJSON(message: WorkflowResponse): unknown {
    const obj: any = {};
    if (message.workflow !== undefined) {
      obj.workflow = Workflow.toJSON(message.workflow);
    }
    return obj;
  },

  create(base?: DeepPartial<WorkflowResponse>): WorkflowResponse {
    return WorkflowResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkflowResponse>): WorkflowResponse {
    const message = createBaseWorkflowResponse();
    message.workflow = (object.workflow !== undefined && object.workflow !== null)
      ? Workflow.fromPartial(object.workflow)
      : undefined;
    return message;
  },
};

function createBaseWorkflow(): Workflow {
  return { name: "", description: "", steps: [], involvedEntities: [], rules: [], edgeCases: [], testScenarios: [] };
}

export const Workflow: MessageFns<Workflow> = {
  encode(message: Workflow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    for (const v of message.steps) {
      WorkflowStep.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.involvedEntities) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.rules) {
      BusinessRule.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.edgeCases) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.testScenarios) {
      writer.uint32(58).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Workflow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.steps.push(WorkflowStep.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.involvedEntities.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.rules.push(BusinessRule.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.edgeCases.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.testScenarios.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Workflow {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      steps: globalThis.Array.isArray(object?.steps) ? object.steps.map((e: any) => WorkflowStep.fromJSON(e)) : [],
      involvedEntities: globalThis.Array.isArray(object?.involvedEntities)
        ? object.involvedEntities.map((e: any) => globalThis.String(e))
        : [],
      rules: globalThis.Array.isArray(object?.rules) ? object.rules.map((e: any) => BusinessRule.fromJSON(e)) : [],
      edgeCases: globalThis.Array.isArray(object?.edgeCases)
        ? object.edgeCases.map((e: any) => globalThis.String(e))
        : [],
      testScenarios: globalThis.Array.isArray(object?.testScenarios)
        ? object.testScenarios.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Workflow): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.steps?.length) {
      obj.steps = message.steps.map((e) => WorkflowStep.toJSON(e));
    }
    if (message.involvedEntities?.length) {
      obj.involvedEntities = message.involvedEntities;
    }
    if (message.rules?.length) {
      obj.rules = message.rules.map((e) => BusinessRule.toJSON(e));
    }
    if (message.edgeCases?.length) {
      obj.edgeCases = message.edgeCases;
    }
    if (message.testScenarios?.length) {
      obj.testScenarios = message.testScenarios;
    }
    return obj;
  },

  create(base?: DeepPartial<Workflow>): Workflow {
    return Workflow.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Workflow>): Workflow {
    const message = createBaseWorkflow();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.steps = object.steps?.map((e) => WorkflowStep.fromPartial(e)) || [];
    message.involvedEntities = object.involvedEntities?.map((e) => e) || [];
    message.rules = object.rules?.map((e) => BusinessRule.fromPartial(e)) || [];
    message.edgeCases = object.edgeCases?.map((e) => e) || [];
    message.testScenarios = object.testScenarios?.map((e) => e) || [];
    return message;
  },
};

function createBaseWorkflowStep(): WorkflowStep {
  return { order: 0, name: "", description: "", entity: "", action: "", validations: [], possibleOutcomes: [] };
}

export const WorkflowStep: MessageFns<WorkflowStep> = {
  encode(message: WorkflowStep, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.order !== 0) {
      writer.uint32(8).int32(message.order);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.entity !== "") {
      writer.uint32(34).string(message.entity);
    }
    if (message.action !== "") {
      writer.uint32(42).string(message.action);
    }
    for (const v of message.validations) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.possibleOutcomes) {
      writer.uint32(58).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkflowStep {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowStep();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.order = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.entity = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.action = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.validations.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.possibleOutcomes.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkflowStep {
    return {
      order: isSet(object.order) ? globalThis.Number(object.order) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      entity: isSet(object.entity) ? globalThis.String(object.entity) : "",
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      validations: globalThis.Array.isArray(object?.validations)
        ? object.validations.map((e: any) => globalThis.String(e))
        : [],
      possibleOutcomes: globalThis.Array.isArray(object?.possibleOutcomes)
        ? object.possibleOutcomes.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: WorkflowStep): unknown {
    const obj: any = {};
    if (message.order !== 0) {
      obj.order = Math.round(message.order);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.entity !== "") {
      obj.entity = message.entity;
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.validations?.length) {
      obj.validations = message.validations;
    }
    if (message.possibleOutcomes?.length) {
      obj.possibleOutcomes = message.possibleOutcomes;
    }
    return obj;
  },

  create(base?: DeepPartial<WorkflowStep>): WorkflowStep {
    return WorkflowStep.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkflowStep>): WorkflowStep {
    const message = createBaseWorkflowStep();
    message.order = object.order ?? 0;
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.entity = object.entity ?? "";
    message.action = object.action ?? "";
    message.validations = object.validations?.map((e) => e) || [];
    message.possibleOutcomes = object.possibleOutcomes?.map((e) => e) || [];
    return message;
  },
};

function createBaseListWorkflowsRequest(): ListWorkflowsRequest {
  return {};
}

export const ListWorkflowsRequest: MessageFns<ListWorkflowsRequest> = {
  encode(_: ListWorkflowsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListWorkflowsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWorkflowsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListWorkflowsRequest {
    return {};
  },

  toJSON(_: ListWorkflowsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ListWorkflowsRequest>): ListWorkflowsRequest {
    return ListWorkflowsRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ListWorkflowsRequest>): ListWorkflowsRequest {
    const message = createBaseListWorkflowsRequest();
    return message;
  },
};

function createBaseListWorkflowsResponse(): ListWorkflowsResponse {
  return { workflows: [] };
}

export const ListWorkflowsResponse: MessageFns<ListWorkflowsResponse> = {
  encode(message: ListWorkflowsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.workflows) {
      WorkflowSummary.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListWorkflowsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWorkflowsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workflows.push(WorkflowSummary.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListWorkflowsResponse {
    return {
      workflows: globalThis.Array.isArray(object?.workflows)
        ? object.workflows.map((e: any) => WorkflowSummary.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListWorkflowsResponse): unknown {
    const obj: any = {};
    if (message.workflows?.length) {
      obj.workflows = message.workflows.map((e) => WorkflowSummary.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListWorkflowsResponse>): ListWorkflowsResponse {
    return ListWorkflowsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListWorkflowsResponse>): ListWorkflowsResponse {
    const message = createBaseListWorkflowsResponse();
    message.workflows = object.workflows?.map((e) => WorkflowSummary.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWorkflowSummary(): WorkflowSummary {
  return { name: "", description: "", stepCount: 0, involvedEntities: [] };
}

export const WorkflowSummary: MessageFns<WorkflowSummary> = {
  encode(message: WorkflowSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.stepCount !== 0) {
      writer.uint32(24).int32(message.stepCount);
    }
    for (const v of message.involvedEntities) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkflowSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.stepCount = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.involvedEntities.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkflowSummary {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      stepCount: isSet(object.stepCount) ? globalThis.Number(object.stepCount) : 0,
      involvedEntities: globalThis.Array.isArray(object?.involvedEntities)
        ? object.involvedEntities.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: WorkflowSummary): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.stepCount !== 0) {
      obj.stepCount = Math.round(message.stepCount);
    }
    if (message.involvedEntities?.length) {
      obj.involvedEntities = message.involvedEntities;
    }
    return obj;
  },

  create(base?: DeepPartial<WorkflowSummary>): WorkflowSummary {
    return WorkflowSummary.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkflowSummary>): WorkflowSummary {
    const message = createBaseWorkflowSummary();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.stepCount = object.stepCount ?? 0;
    message.involvedEntities = object.involvedEntities?.map((e) => e) || [];
    return message;
  },
};

function createBaseEdgeCasesRequest(): EdgeCasesRequest {
  return { entity: "", workflow: "", category: "" };
}

export const EdgeCasesRequest: MessageFns<EdgeCasesRequest> = {
  encode(message: EdgeCasesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.entity !== "") {
      writer.uint32(10).string(message.entity);
    }
    if (message.workflow !== "") {
      writer.uint32(18).string(message.workflow);
    }
    if (message.category !== "") {
      writer.uint32(26).string(message.category);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EdgeCasesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEdgeCasesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entity = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workflow = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.category = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EdgeCasesRequest {
    return {
      entity: isSet(object.entity) ? globalThis.String(object.entity) : "",
      workflow: isSet(object.workflow) ? globalThis.String(object.workflow) : "",
      category: isSet(object.category) ? globalThis.String(object.category) : "",
    };
  },

  toJSON(message: EdgeCasesRequest): unknown {
    const obj: any = {};
    if (message.entity !== "") {
      obj.entity = message.entity;
    }
    if (message.workflow !== "") {
      obj.workflow = message.workflow;
    }
    if (message.category !== "") {
      obj.category = message.category;
    }
    return obj;
  },

  create(base?: DeepPartial<EdgeCasesRequest>): EdgeCasesRequest {
    return EdgeCasesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EdgeCasesRequest>): EdgeCasesRequest {
    const message = createBaseEdgeCasesRequest();
    message.entity = object.entity ?? "";
    message.workflow = object.workflow ?? "";
    message.category = object.category ?? "";
    return message;
  },
};

function createBaseEdgeCasesResponse(): EdgeCasesResponse {
  return { edgeCases: [] };
}

export const EdgeCasesResponse: MessageFns<EdgeCasesResponse> = {
  encode(message: EdgeCasesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.edgeCases) {
      EdgeCase.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EdgeCasesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEdgeCasesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.edgeCases.push(EdgeCase.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EdgeCasesResponse {
    return {
      edgeCases: globalThis.Array.isArray(object?.edgeCases)
        ? object.edgeCases.map((e: any) => EdgeCase.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EdgeCasesResponse): unknown {
    const obj: any = {};
    if (message.edgeCases?.length) {
      obj.edgeCases = message.edgeCases.map((e) => EdgeCase.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<EdgeCasesResponse>): EdgeCasesResponse {
    return EdgeCasesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EdgeCasesResponse>): EdgeCasesResponse {
    const message = createBaseEdgeCasesResponse();
    message.edgeCases = object.edgeCases?.map((e) => EdgeCase.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEdgeCase(): EdgeCase {
  return {
    id: "",
    name: "",
    description: "",
    category: "",
    entity: "",
    workflow: "",
    testApproach: "",
    exampleData: {},
    expectedBehavior: "",
    severity: "",
  };
}

export const EdgeCase: MessageFns<EdgeCase> = {
  encode(message: EdgeCase, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.category !== "") {
      writer.uint32(34).string(message.category);
    }
    if (message.entity !== "") {
      writer.uint32(42).string(message.entity);
    }
    if (message.workflow !== "") {
      writer.uint32(50).string(message.workflow);
    }
    if (message.testApproach !== "") {
      writer.uint32(58).string(message.testApproach);
    }
    Object.entries(message.exampleData).forEach(([key, value]) => {
      EdgeCase_ExampleDataEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    if (message.expectedBehavior !== "") {
      writer.uint32(74).string(message.expectedBehavior);
    }
    if (message.severity !== "") {
      writer.uint32(82).string(message.severity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EdgeCase {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEdgeCase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.category = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.entity = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.workflow = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.testApproach = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const entry8 = EdgeCase_ExampleDataEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.exampleData[entry8.key] = entry8.value;
          }
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.expectedBehavior = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.severity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EdgeCase {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      category: isSet(object.category) ? globalThis.String(object.category) : "",
      entity: isSet(object.entity) ? globalThis.String(object.entity) : "",
      workflow: isSet(object.workflow) ? globalThis.String(object.workflow) : "",
      testApproach: isSet(object.testApproach) ? globalThis.String(object.testApproach) : "",
      exampleData: isObject(object.exampleData)
        ? Object.entries(object.exampleData).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      expectedBehavior: isSet(object.expectedBehavior) ? globalThis.String(object.expectedBehavior) : "",
      severity: isSet(object.severity) ? globalThis.String(object.severity) : "",
    };
  },

  toJSON(message: EdgeCase): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.category !== "") {
      obj.category = message.category;
    }
    if (message.entity !== "") {
      obj.entity = message.entity;
    }
    if (message.workflow !== "") {
      obj.workflow = message.workflow;
    }
    if (message.testApproach !== "") {
      obj.testApproach = message.testApproach;
    }
    if (message.exampleData) {
      const entries = Object.entries(message.exampleData);
      if (entries.length > 0) {
        obj.exampleData = {};
        entries.forEach(([k, v]) => {
          obj.exampleData[k] = v;
        });
      }
    }
    if (message.expectedBehavior !== "") {
      obj.expectedBehavior = message.expectedBehavior;
    }
    if (message.severity !== "") {
      obj.severity = message.severity;
    }
    return obj;
  },

  create(base?: DeepPartial<EdgeCase>): EdgeCase {
    return EdgeCase.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EdgeCase>): EdgeCase {
    const message = createBaseEdgeCase();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.category = object.category ?? "";
    message.entity = object.entity ?? "";
    message.workflow = object.workflow ?? "";
    message.testApproach = object.testApproach ?? "";
    message.exampleData = Object.entries(object.exampleData ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.expectedBehavior = object.expectedBehavior ?? "";
    message.severity = object.severity ?? "";
    return message;
  },
};

function createBaseEdgeCase_ExampleDataEntry(): EdgeCase_ExampleDataEntry {
  return { key: "", value: "" };
}

export const EdgeCase_ExampleDataEntry: MessageFns<EdgeCase_ExampleDataEntry> = {
  encode(message: EdgeCase_ExampleDataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EdgeCase_ExampleDataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEdgeCase_ExampleDataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EdgeCase_ExampleDataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: EdgeCase_ExampleDataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<EdgeCase_ExampleDataEntry>): EdgeCase_ExampleDataEntry {
    return EdgeCase_ExampleDataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EdgeCase_ExampleDataEntry>): EdgeCase_ExampleDataEntry {
    const message = createBaseEdgeCase_ExampleDataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGenerateTestDataRequest(): GenerateTestDataRequest {
  return {
    requestId: "",
    entity: "",
    count: 0,
    workflowContext: "",
    scenarios: [],
    customContext: "",
    includeEdgeCases: false,
    outputFormat: "",
    scenarioCounts: {},
    generationMethod: 0,
    productionLike: false,
    useCache: false,
  };
}

export const GenerateTestDataRequest: MessageFns<GenerateTestDataRequest> = {
  encode(message: GenerateTestDataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.entity !== "") {
      writer.uint32(18).string(message.entity);
    }
    if (message.count !== 0) {
      writer.uint32(24).int32(message.count);
    }
    if (message.workflowContext !== "") {
      writer.uint32(34).string(message.workflowContext);
    }
    for (const v of message.scenarios) {
      writer.uint32(42).string(v!);
    }
    if (message.customContext !== "") {
      writer.uint32(50).string(message.customContext);
    }
    if (message.includeEdgeCases !== false) {
      writer.uint32(56).bool(message.includeEdgeCases);
    }
    if (message.outputFormat !== "") {
      writer.uint32(66).string(message.outputFormat);
    }
    Object.entries(message.scenarioCounts).forEach(([key, value]) => {
      GenerateTestDataRequest_ScenarioCountsEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).join();
    });
    if (message.generationMethod !== 0) {
      writer.uint32(80).int32(message.generationMethod);
    }
    if (message.productionLike !== false) {
      writer.uint32(88).bool(message.productionLike);
    }
    if (message.useCache !== false) {
      writer.uint32(96).bool(message.useCache);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateTestDataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateTestDataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.entity = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.count = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.workflowContext = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.scenarios.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.customContext = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.includeEdgeCases = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.outputFormat = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          const entry9 = GenerateTestDataRequest_ScenarioCountsEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.scenarioCounts[entry9.key] = entry9.value;
          }
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.generationMethod = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.productionLike = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.useCache = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateTestDataRequest {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      entity: isSet(object.entity) ? globalThis.String(object.entity) : "",
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
      workflowContext: isSet(object.workflowContext) ? globalThis.String(object.workflowContext) : "",
      scenarios: globalThis.Array.isArray(object?.scenarios)
        ? object.scenarios.map((e: any) => globalThis.String(e))
        : [],
      customContext: isSet(object.customContext) ? globalThis.String(object.customContext) : "",
      includeEdgeCases: isSet(object.includeEdgeCases) ? globalThis.Boolean(object.includeEdgeCases) : false,
      outputFormat: isSet(object.outputFormat) ? globalThis.String(object.outputFormat) : "",
      scenarioCounts: isObject(object.scenarioCounts)
        ? Object.entries(object.scenarioCounts).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
      generationMethod: isSet(object.generationMethod) ? generationMethodFromJSON(object.generationMethod) : 0,
      productionLike: isSet(object.productionLike) ? globalThis.Boolean(object.productionLike) : false,
      useCache: isSet(object.useCache) ? globalThis.Boolean(object.useCache) : false,
    };
  },

  toJSON(message: GenerateTestDataRequest): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.entity !== "") {
      obj.entity = message.entity;
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.workflowContext !== "") {
      obj.workflowContext = message.workflowContext;
    }
    if (message.scenarios?.length) {
      obj.scenarios = message.scenarios;
    }
    if (message.customContext !== "") {
      obj.customContext = message.customContext;
    }
    if (message.includeEdgeCases !== false) {
      obj.includeEdgeCases = message.includeEdgeCases;
    }
    if (message.outputFormat !== "") {
      obj.outputFormat = message.outputFormat;
    }
    if (message.scenarioCounts) {
      const entries = Object.entries(message.scenarioCounts);
      if (entries.length > 0) {
        obj.scenarioCounts = {};
        entries.forEach(([k, v]) => {
          obj.scenarioCounts[k] = Math.round(v);
        });
      }
    }
    if (message.generationMethod !== 0) {
      obj.generationMethod = generationMethodToJSON(message.generationMethod);
    }
    if (message.productionLike !== false) {
      obj.productionLike = message.productionLike;
    }
    if (message.useCache !== false) {
      obj.useCache = message.useCache;
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateTestDataRequest>): GenerateTestDataRequest {
    return GenerateTestDataRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateTestDataRequest>): GenerateTestDataRequest {
    const message = createBaseGenerateTestDataRequest();
    message.requestId = object.requestId ?? "";
    message.entity = object.entity ?? "";
    message.count = object.count ?? 0;
    message.workflowContext = object.workflowContext ?? "";
    message.scenarios = object.scenarios?.map((e) => e) || [];
    message.customContext = object.customContext ?? "";
    message.includeEdgeCases = object.includeEdgeCases ?? false;
    message.outputFormat = object.outputFormat ?? "";
    message.scenarioCounts = Object.entries(object.scenarioCounts ?? {}).reduce<{ [key: string]: number }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.Number(value);
        }
        return acc;
      },
      {},
    );
    message.generationMethod = object.generationMethod ?? 0;
    message.productionLike = object.productionLike ?? false;
    message.useCache = object.useCache ?? false;
    return message;
  },
};

function createBaseGenerateTestDataRequest_ScenarioCountsEntry(): GenerateTestDataRequest_ScenarioCountsEntry {
  return { key: "", value: 0 };
}

export const GenerateTestDataRequest_ScenarioCountsEntry: MessageFns<GenerateTestDataRequest_ScenarioCountsEntry> = {
  encode(
    message: GenerateTestDataRequest_ScenarioCountsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateTestDataRequest_ScenarioCountsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateTestDataRequest_ScenarioCountsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateTestDataRequest_ScenarioCountsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: GenerateTestDataRequest_ScenarioCountsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateTestDataRequest_ScenarioCountsEntry>): GenerateTestDataRequest_ScenarioCountsEntry {
    return GenerateTestDataRequest_ScenarioCountsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GenerateTestDataRequest_ScenarioCountsEntry>,
  ): GenerateTestDataRequest_ScenarioCountsEntry {
    const message = createBaseGenerateTestDataRequest_ScenarioCountsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseGenerateTestDataResponse(): GenerateTestDataResponse {
  return { requestId: "", success: false, data: "", recordCount: 0, metadata: undefined, error: "" };
}

export const GenerateTestDataResponse: MessageFns<GenerateTestDataResponse> = {
  encode(message: GenerateTestDataResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.data !== "") {
      writer.uint32(26).string(message.data);
    }
    if (message.recordCount !== 0) {
      writer.uint32(32).int32(message.recordCount);
    }
    if (message.metadata !== undefined) {
      GenerationMetadata.encode(message.metadata, writer.uint32(42).fork()).join();
    }
    if (message.error !== "") {
      writer.uint32(50).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateTestDataResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateTestDataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.recordCount = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.metadata = GenerationMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateTestDataResponse {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      data: isSet(object.data) ? globalThis.String(object.data) : "",
      recordCount: isSet(object.recordCount) ? globalThis.Number(object.recordCount) : 0,
      metadata: isSet(object.metadata) ? GenerationMetadata.fromJSON(object.metadata) : undefined,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: GenerateTestDataResponse): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.data !== "") {
      obj.data = message.data;
    }
    if (message.recordCount !== 0) {
      obj.recordCount = Math.round(message.recordCount);
    }
    if (message.metadata !== undefined) {
      obj.metadata = GenerationMetadata.toJSON(message.metadata);
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateTestDataResponse>): GenerateTestDataResponse {
    return GenerateTestDataResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateTestDataResponse>): GenerateTestDataResponse {
    const message = createBaseGenerateTestDataResponse();
    message.requestId = object.requestId ?? "";
    message.success = object.success ?? false;
    message.data = object.data ?? "";
    message.recordCount = object.recordCount ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? GenerationMetadata.fromPartial(object.metadata)
      : undefined;
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseGenerationMetadata(): GenerationMetadata {
  return {
    generationPath: "",
    llmTokensUsed: 0,
    generationTimeMs: 0,
    coherenceScore: 0,
    domainContextUsed: "",
    scenarioCounts: {},
  };
}

export const GenerationMetadata: MessageFns<GenerationMetadata> = {
  encode(message: GenerationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.generationPath !== "") {
      writer.uint32(10).string(message.generationPath);
    }
    if (message.llmTokensUsed !== 0) {
      writer.uint32(16).int32(message.llmTokensUsed);
    }
    if (message.generationTimeMs !== 0) {
      writer.uint32(29).float(message.generationTimeMs);
    }
    if (message.coherenceScore !== 0) {
      writer.uint32(37).float(message.coherenceScore);
    }
    if (message.domainContextUsed !== "") {
      writer.uint32(42).string(message.domainContextUsed);
    }
    Object.entries(message.scenarioCounts).forEach(([key, value]) => {
      GenerationMetadata_ScenarioCountsEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.generationPath = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.llmTokensUsed = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.generationTimeMs = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.coherenceScore = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.domainContextUsed = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = GenerationMetadata_ScenarioCountsEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.scenarioCounts[entry6.key] = entry6.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerationMetadata {
    return {
      generationPath: isSet(object.generationPath) ? globalThis.String(object.generationPath) : "",
      llmTokensUsed: isSet(object.llmTokensUsed) ? globalThis.Number(object.llmTokensUsed) : 0,
      generationTimeMs: isSet(object.generationTimeMs) ? globalThis.Number(object.generationTimeMs) : 0,
      coherenceScore: isSet(object.coherenceScore) ? globalThis.Number(object.coherenceScore) : 0,
      domainContextUsed: isSet(object.domainContextUsed) ? globalThis.String(object.domainContextUsed) : "",
      scenarioCounts: isObject(object.scenarioCounts)
        ? Object.entries(object.scenarioCounts).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: GenerationMetadata): unknown {
    const obj: any = {};
    if (message.generationPath !== "") {
      obj.generationPath = message.generationPath;
    }
    if (message.llmTokensUsed !== 0) {
      obj.llmTokensUsed = Math.round(message.llmTokensUsed);
    }
    if (message.generationTimeMs !== 0) {
      obj.generationTimeMs = message.generationTimeMs;
    }
    if (message.coherenceScore !== 0) {
      obj.coherenceScore = message.coherenceScore;
    }
    if (message.domainContextUsed !== "") {
      obj.domainContextUsed = message.domainContextUsed;
    }
    if (message.scenarioCounts) {
      const entries = Object.entries(message.scenarioCounts);
      if (entries.length > 0) {
        obj.scenarioCounts = {};
        entries.forEach(([k, v]) => {
          obj.scenarioCounts[k] = Math.round(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<GenerationMetadata>): GenerationMetadata {
    return GenerationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerationMetadata>): GenerationMetadata {
    const message = createBaseGenerationMetadata();
    message.generationPath = object.generationPath ?? "";
    message.llmTokensUsed = object.llmTokensUsed ?? 0;
    message.generationTimeMs = object.generationTimeMs ?? 0;
    message.coherenceScore = object.coherenceScore ?? 0;
    message.domainContextUsed = object.domainContextUsed ?? "";
    message.scenarioCounts = Object.entries(object.scenarioCounts ?? {}).reduce<{ [key: string]: number }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.Number(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseGenerationMetadata_ScenarioCountsEntry(): GenerationMetadata_ScenarioCountsEntry {
  return { key: "", value: 0 };
}

export const GenerationMetadata_ScenarioCountsEntry: MessageFns<GenerationMetadata_ScenarioCountsEntry> = {
  encode(message: GenerationMetadata_ScenarioCountsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerationMetadata_ScenarioCountsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerationMetadata_ScenarioCountsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerationMetadata_ScenarioCountsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: GenerationMetadata_ScenarioCountsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerationMetadata_ScenarioCountsEntry>): GenerationMetadata_ScenarioCountsEntry {
    return GenerationMetadata_ScenarioCountsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerationMetadata_ScenarioCountsEntry>): GenerationMetadata_ScenarioCountsEntry {
    const message = createBaseGenerationMetadata_ScenarioCountsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseHealthCheckRequest(): HealthCheckRequest {
  return {};
}

export const HealthCheckRequest: MessageFns<HealthCheckRequest> = {
  encode(_: HealthCheckRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): HealthCheckRequest {
    return {};
  },

  toJSON(_: HealthCheckRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<HealthCheckRequest>): HealthCheckRequest {
    return HealthCheckRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<HealthCheckRequest>): HealthCheckRequest {
    const message = createBaseHealthCheckRequest();
    return message;
  },
};

function createBaseHealthCheckResponse(): HealthCheckResponse {
  return { status: "", components: {} };
}

export const HealthCheckResponse: MessageFns<HealthCheckResponse> = {
  encode(message: HealthCheckResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    Object.entries(message.components).forEach(([key, value]) => {
      HealthCheckResponse_ComponentsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = HealthCheckResponse_ComponentsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.components[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheckResponse {
    return {
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      components: isObject(object.components)
        ? Object.entries(object.components).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: HealthCheckResponse): unknown {
    const obj: any = {};
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.components) {
      const entries = Object.entries(message.components);
      if (entries.length > 0) {
        obj.components = {};
        entries.forEach(([k, v]) => {
          obj.components[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<HealthCheckResponse>): HealthCheckResponse {
    return HealthCheckResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HealthCheckResponse>): HealthCheckResponse {
    const message = createBaseHealthCheckResponse();
    message.status = object.status ?? "";
    message.components = Object.entries(object.components ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseHealthCheckResponse_ComponentsEntry(): HealthCheckResponse_ComponentsEntry {
  return { key: "", value: "" };
}

export const HealthCheckResponse_ComponentsEntry: MessageFns<HealthCheckResponse_ComponentsEntry> = {
  encode(message: HealthCheckResponse_ComponentsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckResponse_ComponentsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckResponse_ComponentsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheckResponse_ComponentsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: HealthCheckResponse_ComponentsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<HealthCheckResponse_ComponentsEntry>): HealthCheckResponse_ComponentsEntry {
    return HealthCheckResponse_ComponentsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HealthCheckResponse_ComponentsEntry>): HealthCheckResponse_ComponentsEntry {
    const message = createBaseHealthCheckResponse_ComponentsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

/** Service exposed by eCommerce Domain Agent */
export type EcommerceDomainServiceDefinition = typeof EcommerceDomainServiceDefinition;
export const EcommerceDomainServiceDefinition = {
  name: "EcommerceDomainService",
  fullName: "ecommerce.domain.v1.EcommerceDomainService",
  methods: {
    /** Get domain context for test generation */
    getDomainContext: {
      name: "GetDomainContext",
      requestType: DomainContextRequest,
      requestStream: false,
      responseType: DomainContextResponse,
      responseStream: false,
      options: {},
    },
    /** Query domain knowledge */
    queryKnowledge: {
      name: "QueryKnowledge",
      requestType: KnowledgeRequest,
      requestStream: false,
      responseType: KnowledgeResponse,
      responseStream: false,
      options: {},
    },
    /** Get entity details */
    getEntity: {
      name: "GetEntity",
      requestType: EntityRequest,
      requestStream: false,
      responseType: EntityResponse,
      responseStream: false,
      options: {},
    },
    /** Get workflow details */
    getWorkflow: {
      name: "GetWorkflow",
      requestType: WorkflowRequest,
      requestStream: false,
      responseType: WorkflowResponse,
      responseStream: false,
      options: {},
    },
    /** List all entities */
    listEntities: {
      name: "ListEntities",
      requestType: ListEntitiesRequest,
      requestStream: false,
      responseType: ListEntitiesResponse,
      responseStream: false,
      options: {},
    },
    /** List all workflows */
    listWorkflows: {
      name: "ListWorkflows",
      requestType: ListWorkflowsRequest,
      requestStream: false,
      responseType: ListWorkflowsResponse,
      responseStream: false,
      options: {},
    },
    /** Get edge cases for an entity/workflow */
    getEdgeCases: {
      name: "GetEdgeCases",
      requestType: EdgeCasesRequest,
      requestStream: false,
      responseType: EdgeCasesResponse,
      responseStream: false,
      options: {},
    },
    /** Generate test data (proxies to Test Data Agent with domain context) */
    generateTestData: {
      name: "GenerateTestData",
      requestType: GenerateTestDataRequest,
      requestStream: false,
      responseType: GenerateTestDataResponse,
      responseStream: false,
      options: {},
    },
    /** Health check */
    healthCheck: {
      name: "HealthCheck",
      requestType: HealthCheckRequest,
      requestStream: false,
      responseType: HealthCheckResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface EcommerceDomainServiceImplementation<CallContextExt = {}> {
  /** Get domain context for test generation */
  getDomainContext(
    request: DomainContextRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<DomainContextResponse>>;
  /** Query domain knowledge */
  queryKnowledge(
    request: KnowledgeRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<KnowledgeResponse>>;
  /** Get entity details */
  getEntity(request: EntityRequest, context: CallContext & CallContextExt): Promise<DeepPartial<EntityResponse>>;
  /** Get workflow details */
  getWorkflow(request: WorkflowRequest, context: CallContext & CallContextExt): Promise<DeepPartial<WorkflowResponse>>;
  /** List all entities */
  listEntities(
    request: ListEntitiesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListEntitiesResponse>>;
  /** List all workflows */
  listWorkflows(
    request: ListWorkflowsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListWorkflowsResponse>>;
  /** Get edge cases for an entity/workflow */
  getEdgeCases(
    request: EdgeCasesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<EdgeCasesResponse>>;
  /** Generate test data (proxies to Test Data Agent with domain context) */
  generateTestData(
    request: GenerateTestDataRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GenerateTestDataResponse>>;
  /** Health check */
  healthCheck(
    request: HealthCheckRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<HealthCheckResponse>>;
}

export interface EcommerceDomainServiceClient<CallOptionsExt = {}> {
  /** Get domain context for test generation */
  getDomainContext(
    request: DeepPartial<DomainContextRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<DomainContextResponse>;
  /** Query domain knowledge */
  queryKnowledge(
    request: DeepPartial<KnowledgeRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<KnowledgeResponse>;
  /** Get entity details */
  getEntity(request: DeepPartial<EntityRequest>, options?: CallOptions & CallOptionsExt): Promise<EntityResponse>;
  /** Get workflow details */
  getWorkflow(request: DeepPartial<WorkflowRequest>, options?: CallOptions & CallOptionsExt): Promise<WorkflowResponse>;
  /** List all entities */
  listEntities(
    request: DeepPartial<ListEntitiesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListEntitiesResponse>;
  /** List all workflows */
  listWorkflows(
    request: DeepPartial<ListWorkflowsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListWorkflowsResponse>;
  /** Get edge cases for an entity/workflow */
  getEdgeCases(
    request: DeepPartial<EdgeCasesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<EdgeCasesResponse>;
  /** Generate test data (proxies to Test Data Agent with domain context) */
  generateTestData(
    request: DeepPartial<GenerateTestDataRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GenerateTestDataResponse>;
  /** Health check */
  healthCheck(
    request: DeepPartial<HealthCheckRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<HealthCheckResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
